"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module2) {
    "use strict";
    module2.exports = isexe;
    isexe.sync = sync;
    var fs16 = require("fs");
    function checkPathExt(path11, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path11.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path11, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path11, options);
    }
    function isexe(path11, options, cb) {
      fs16.stat(path11, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path11, options));
      });
    }
    function sync(path11, options) {
      return checkStat(fs16.statSync(path11), path11, options);
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module2) {
    "use strict";
    module2.exports = isexe;
    isexe.sync = sync;
    var fs16 = require("fs");
    function isexe(path11, options, cb) {
      fs16.stat(path11, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path11, options) {
      return checkStat(fs16.statSync(path11), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module2) {
    "use strict";
    var fs16 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path11, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve15, reject) {
          isexe(path11, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve15(is);
            }
          });
        });
      }
      core(path11, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path11, options) {
      try {
        return core.sync(path11, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports, module2) {
    "use strict";
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path11 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve15, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve15(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path11.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve15(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve15, reject) => {
        if (ii === pathExt.length)
          return resolve15(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve15(p + ext);
          }
          return resolve15(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path11.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    var pathKey2 = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path11 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({ env })],
          pathExt: withoutPathExt ? path11.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path11.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path11, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path11.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs16 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs16.openSync(command, "r");
        fs16.readSync(fd, buffer, 0, size, 0);
        fs16.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path11 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path11.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});

// node_modules/.pnpm/strip-final-newline@3.0.0/node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
  const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
  if (input[input.length - 1] === LF) {
    input = input.slice(0, -1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, -1);
  }
  return input;
}
var init_strip_final_newline = __esm({
  "node_modules/.pnpm/strip-final-newline@3.0.0/node_modules/strip-final-newline/index.js"() {
    "use strict";
  }
});

// node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env = process.env,
    platform = process.platform
  } = options;
  if (platform !== "win32") {
    return "PATH";
  }
  return Object.keys(env).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}
var init_path_key = __esm({
  "node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js"() {
    "use strict";
  }
});

// node_modules/.pnpm/npm-run-path@5.1.0/node_modules/npm-run-path/index.js
function npmRunPath(options = {}) {
  const {
    cwd = import_node_process.default.cwd(),
    path: path_ = import_node_process.default.env[pathKey()],
    execPath = import_node_process.default.execPath
  } = options;
  let previous;
  const cwdString = cwd instanceof URL ? import_node_url2.default.fileURLToPath(cwd) : cwd;
  let cwdPath = import_node_path12.default.resolve(cwdString);
  const result = [];
  while (previous !== cwdPath) {
    result.push(import_node_path12.default.join(cwdPath, "node_modules/.bin"));
    previous = cwdPath;
    cwdPath = import_node_path12.default.resolve(cwdPath, "..");
  }
  result.push(import_node_path12.default.resolve(cwdString, execPath, ".."));
  return [...result, path_].join(import_node_path12.default.delimiter);
}
function npmRunPathEnv({ env = import_node_process.default.env, ...options } = {}) {
  env = { ...env };
  const path11 = pathKey({ env });
  options.path = env[path11];
  env[path11] = npmRunPath(options);
  return env;
}
var import_node_process, import_node_path12, import_node_url2;
var init_npm_run_path = __esm({
  "node_modules/.pnpm/npm-run-path@5.1.0/node_modules/npm-run-path/index.js"() {
    "use strict";
    import_node_process = __toESM(require("process"), 1);
    import_node_path12 = __toESM(require("path"), 1);
    import_node_url2 = __toESM(require("url"), 1);
    init_path_key();
  }
});

// node_modules/.pnpm/mimic-fn@4.0.0/node_modules/mimic-fn/index.js
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}
var copyProperty, canCopyProperty, changePrototype, wrappedToString, toStringDescriptor, toStringName, changeToString;
var init_mimic_fn = __esm({
  "node_modules/.pnpm/mimic-fn@4.0.0/node_modules/mimic-fn/index.js"() {
    "use strict";
    copyProperty = (to, from, property, ignoreNonConfigurable) => {
      if (property === "length" || property === "prototype") {
        return;
      }
      if (property === "arguments" || property === "caller") {
        return;
      }
      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
      }
      Object.defineProperty(to, property, fromDescriptor);
    };
    canCopyProperty = function(toDescriptor, fromDescriptor) {
      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    changePrototype = (to, from) => {
      const fromPrototype = Object.getPrototypeOf(from);
      if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
      }
      Object.setPrototypeOf(to, fromPrototype);
    };
    wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
    toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
    toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
    changeToString = (to, from, name) => {
      const withName = name === "" ? "" : `with ${name.trim()}() `;
      const newToString = wrappedToString.bind(null, withName, from.toString());
      Object.defineProperty(newToString, "name", toStringName);
      Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
    };
  }
});

// node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js
var calledFunctions, onetime, onetime_default;
var init_onetime = __esm({
  "node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js"() {
    "use strict";
    init_mimic_fn();
    calledFunctions = /* @__PURE__ */ new WeakMap();
    onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFunction(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    onetime.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
    onetime_default = onetime;
  }
});

// node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals, getRealtimeSignal, SIGRTMIN, SIGRTMAX;
var init_realtime = __esm({
  "node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/realtime.js"() {
    "use strict";
    getRealtimeSignals = () => {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    };
    getRealtimeSignal = (value, index) => ({
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    });
    SIGRTMIN = 34;
    SIGRTMAX = 64;
  }
});

// node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/core.js
var SIGNALS;
var init_core = __esm({
  "node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/core.js"() {
    "use strict";
    SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
  }
});

// node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/signals.js
var import_node_os, getSignals, normalizeSignal;
var init_signals = __esm({
  "node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/signals.js"() {
    "use strict";
    import_node_os = require("os");
    init_core();
    init_realtime();
    getSignals = () => {
      const realtimeSignals = getRealtimeSignals();
      const signals2 = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals2;
    };
    normalizeSignal = ({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) => {
      const {
        signals: { [name]: constantSignal }
      } = import_node_os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    };
  }
});

// node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/main.js
var import_node_os2, getSignalsByName, getSignalByName, signalsByName, getSignalsByNumber, getSignalByNumber, findSignalByNumber, signalsByNumber;
var init_main = __esm({
  "node_modules/.pnpm/human-signals@5.0.0/node_modules/human-signals/build/src/main.js"() {
    "use strict";
    import_node_os2 = require("os");
    init_realtime();
    init_signals();
    getSignalsByName = () => {
      const signals2 = getSignals();
      return Object.fromEntries(signals2.map(getSignalByName));
    };
    getSignalByName = ({
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }) => [name, { name, number, description, supported, action, forced, standard }];
    signalsByName = getSignalsByName();
    getSignalsByNumber = () => {
      const signals2 = getSignals();
      const length = SIGRTMAX + 1;
      const signalsA = Array.from(
        { length },
        (value, number) => getSignalByNumber(number, signals2)
      );
      return Object.assign({}, ...signalsA);
    };
    getSignalByNumber = (number, signals2) => {
      const signal = findSignalByNumber(number, signals2);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    findSignalByNumber = (number, signals2) => {
      const signal = signals2.find(({ name }) => import_node_os2.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals2.find((signalA) => signalA.number === number);
    };
    signalsByNumber = getSignalsByNumber();
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/error.js
var import_node_process2, getErrorPrefix, makeError;
var init_error = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/error.js"() {
    "use strict";
    import_node_process2 = __toESM(require("process"), 1);
    init_main();
    getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout, cwd = import_node_process2.default.cwd() } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      error.cwd = cwd;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/stdio.js
var aliases, hasAlias, normalizeStdio, normalizeStdioNode;
var init_stdio = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/stdio.js"() {
    "use strict";
    aliases = ["stdin", "stdout", "stderr"];
    hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
    normalizeStdio = (options) => {
      if (!options) {
        return;
      }
      const { stdio } = options;
      if (stdio === void 0) {
        return aliases.map((alias) => options[alias]);
      }
      if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    };
    normalizeStdioNode = (options) => {
      const stdio = normalizeStdio(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});

// node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/signals.js
var signals;
var init_signals2 = __esm({
  "node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/signals.js"() {
    "use strict";
    signals = [];
    signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/index.js
var processOk, kExitEmitter, global2, ObjectDefineProperty, Emitter, SignalExitBase, signalExitWrap, SignalExitFallback, SignalExit, process4, onExit, load, unload;
var init_mjs = __esm({
  "node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/index.js"() {
    "use strict";
    init_signals2();
    processOk = (process7) => !!process7 && typeof process7 === "object" && typeof process7.removeListener === "function" && typeof process7.emit === "function" && typeof process7.reallyExit === "function" && typeof process7.listeners === "function" && typeof process7.kill === "function" && typeof process7.pid === "number" && typeof process7.on === "function";
    kExitEmitter = Symbol.for("signal-exit emitter");
    global2 = globalThis;
    ObjectDefineProperty = Object.defineProperty.bind(Object);
    Emitter = class {
      emitted = {
        afterExit: false,
        exit: false
      };
      listeners = {
        afterExit: [],
        exit: []
      };
      count = 0;
      id = Math.random();
      constructor() {
        if (global2[kExitEmitter]) {
          return global2[kExitEmitter];
        }
        ObjectDefineProperty(global2, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    SignalExitBase = class {
    };
    signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    SignalExit = class extends SignalExitBase {
      // "SIGHUP" throws an `ENOSYS` error on Windows,
      // so use a supported signal instead
      /* c8 ignore start */
      #hupSig = process4.platform === "win32" ? "SIGINT" : "SIGHUP";
      /* c8 ignore stop */
      #emitter = new Emitter();
      #process;
      #originalProcessEmit;
      #originalProcessReallyExit;
      #sigListeners = {};
      #loaded = false;
      constructor(process7) {
        super();
        this.#process = process7;
        this.#sigListeners = {};
        for (const sig of signals) {
          this.#sigListeners[sig] = () => {
            const listeners = this.#process.listeners(sig);
            let { count } = this.#emitter;
            const p = process7;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = this.#emitter.emit("exit", null, sig);
              const s = sig === "SIGHUP" ? this.#hupSig : sig;
              if (!ret)
                process7.kill(process7.pid, s);
            }
          };
        }
        this.#originalProcessReallyExit = process7.reallyExit;
        this.#originalProcessEmit = process7.emit;
      }
      onExit(cb, opts) {
        if (!processOk(this.#process)) {
          return () => {
          };
        }
        if (this.#loaded === false) {
          this.load();
        }
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return () => {
          this.#emitter.removeListener(ev, cb);
          if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (this.#loaded) {
          return;
        }
        this.#loaded = true;
        this.#emitter.count += 1;
        for (const sig of signals) {
          try {
            const fn = this.#sigListeners[sig];
            if (fn)
              this.#process.on(sig, fn);
          } catch (_) {
          }
        }
        this.#process.emit = (ev, ...a) => {
          return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
          return this.#processReallyExit(code);
        };
      }
      unload() {
        if (!this.#loaded) {
          return;
        }
        this.#loaded = false;
        signals.forEach((sig) => {
          const listener = this.#sigListeners[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            this.#process.removeListener(sig, listener);
          } catch (_) {
          }
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
      }
      #processReallyExit(code) {
        if (!processOk(this.#process)) {
          return 0;
        }
        this.#process.exitCode = code || 0;
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
      }
      #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && processOk(this.#process)) {
          if (typeof args[0] === "number") {
            this.#process.exitCode = args[0];
          }
          const ret = og.call(this.#process, ev, ...args);
          this.#emitter.emit("exit", this.#process.exitCode, null);
          return ret;
        } else {
          return og.call(this.#process, ev, ...args);
        }
      }
    };
    process4 = globalThis.process;
    ({
      onExit: (
        /**
         * Called when the process is exiting, whether via signal, explicit
         * exit, or running out of stuff to do.
         *
         * If the global process object is not suitable for instrumentation,
         * then this will be a no-op.
         *
         * Returns a function that may be used to unload signal-exit.
         */
        onExit
      ),
      load: (
        /**
         * Load the listeners.  Likely you never need to call this, unless
         * doing a rather deep integration with signal-exit functionality.
         * Mostly exposed for the benefit of testing.
         *
         * @internal
         */
        load
      ),
      unload: (
        /**
         * Unload the listeners.  Likely you never need to call this, unless
         * doing a rather deep integration with signal-exit functionality.
         * Mostly exposed for the benefit of testing.
         *
         * @internal
         */
        unload
      )
    } = signalExitWrap(processOk(process4) ? new SignalExit(process4) : new SignalExitFallback()));
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/kill.js
var import_node_os3, DEFAULT_FORCE_KILL_TIMEOUT, spawnedKill, setKillTimeout, shouldForceKill, isSigterm, getForceKillAfterTimeout, spawnedCancel, timeoutKill, setupTimeout, validateTimeout, setExitHandler;
var init_kill = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/kill.js"() {
    "use strict";
    import_node_os3 = __toESM(require("os"), 1);
    init_mjs();
    DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options, killResult);
      return killResult;
    };
    setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    isSigterm = (signal) => signal === import_node_os3.default.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    spawnedCancel = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve15, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    validateTimeout = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
  }
});

// node_modules/.pnpm/is-stream@3.0.0/node_modules/is-stream/index.js
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
var init_is_stream = __esm({
  "node_modules/.pnpm/is-stream@3.0.0/node_modules/is-stream/index.js"() {
    "use strict";
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/pipe.js
var import_node_fs, import_node_child_process, isExecaChildProcess, pipeToTarget, addPipeMethods;
var init_pipe = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/pipe.js"() {
    "use strict";
    import_node_fs = require("fs");
    import_node_child_process = require("child_process");
    init_is_stream();
    isExecaChildProcess = (target) => target instanceof import_node_child_process.ChildProcess && typeof target.then === "function";
    pipeToTarget = (spawned, streamName, target) => {
      if (typeof target === "string") {
        spawned[streamName].pipe((0, import_node_fs.createWriteStream)(target));
        return spawned;
      }
      if (isWritableStream(target)) {
        spawned[streamName].pipe(target);
        return spawned;
      }
      if (!isExecaChildProcess(target)) {
        throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
      }
      if (!isWritableStream(target.stdin)) {
        throw new TypeError("The target child process's stdin must be available.");
      }
      spawned[streamName].pipe(target.stdin);
      return target;
    };
    addPipeMethods = (spawned) => {
      if (spawned.stdout !== null) {
        spawned.pipeStdout = pipeToTarget.bind(void 0, spawned, "stdout");
      }
      if (spawned.stderr !== null) {
        spawned.pipeStderr = pipeToTarget.bind(void 0, spawned, "stderr");
      }
      if (spawned.all !== void 0) {
        spawned.pipeAll = pipeToTarget.bind(void 0, spawned, "all");
      }
    };
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/contents.js
var getStreamContents, appendFinalChunk, appendChunk, addNewChunk, isAsyncIterable, getChunkType, objectToString, MaxBufferError;
var init_contents = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/contents.js"() {
    "use strict";
    getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
      if (!isAsyncIterable(stream)) {
        throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
      }
      const state = init();
      state.length = 0;
      try {
        for await (const chunk of stream) {
          const chunkType = getChunkType(chunk);
          const convertedChunk = convertChunk[chunkType](chunk, state);
          appendChunk({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer });
        }
        appendFinalChunk({ state, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer });
        return finalize(state);
      } catch (error) {
        error.bufferedData = finalize(state);
        throw error;
      }
    };
    appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
      const convertedChunk = getFinalChunk(state);
      if (convertedChunk !== void 0) {
        appendChunk({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer });
      }
    };
    appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
      const chunkSize = getSize(convertedChunk);
      const newLength = state.length + chunkSize;
      if (newLength <= maxBuffer) {
        addNewChunk(convertedChunk, state, addChunk, newLength);
        return;
      }
      const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
      if (truncatedChunk !== void 0) {
        addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
      }
      throw new MaxBufferError();
    };
    addNewChunk = (convertedChunk, state, addChunk, newLength) => {
      state.contents = addChunk(convertedChunk, state, newLength);
      state.length = newLength;
    };
    isAsyncIterable = (stream) => typeof stream === "object" && stream !== null && typeof stream[Symbol.asyncIterator] === "function";
    getChunkType = (chunk) => {
      const typeOfChunk = typeof chunk;
      if (typeOfChunk === "string") {
        return "string";
      }
      if (typeOfChunk !== "object" || chunk === null) {
        return "others";
      }
      if (globalThis.Buffer?.isBuffer(chunk)) {
        return "buffer";
      }
      const prototypeName = objectToString.call(chunk);
      if (prototypeName === "[object ArrayBuffer]") {
        return "arrayBuffer";
      }
      if (prototypeName === "[object DataView]") {
        return "dataView";
      }
      if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString.call(chunk.buffer) === "[object ArrayBuffer]") {
        return "typedArray";
      }
      return "others";
    };
    ({ toString: objectToString } = Object.prototype);
    MaxBufferError = class extends Error {
      name = "MaxBufferError";
      constructor() {
        super("maxBuffer exceeded");
      }
    };
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/utils.js
var identity, noop, getContentsProp, throwObjectStream, getLengthProp;
var init_utils = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/utils.js"() {
    "use strict";
    identity = (value) => value;
    noop = () => void 0;
    getContentsProp = ({ contents }) => contents;
    throwObjectStream = (chunk) => {
      throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
    };
    getLengthProp = (convertedChunk) => convertedChunk.length;
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/array.js
var init_array = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/array.js"() {
    "use strict";
    init_contents();
    init_utils();
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream, options) {
  return getStreamContents(stream, arrayBufferMethods, options);
}
var initArrayBuffer, useTextEncoder, textEncoder, useUint8Array, useUint8ArrayWithOffset, truncateArrayBufferChunk, addArrayBufferChunk, resizeArrayBufferSlow, resizeArrayBuffer, getNewContentsLength, SCALE_FACTOR, finalizeArrayBuffer, hasArrayBufferResize, arrayBufferMethods;
var init_array_buffer = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/array-buffer.js"() {
    "use strict";
    init_contents();
    init_utils();
    initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
    useTextEncoder = (chunk) => textEncoder.encode(chunk);
    textEncoder = new TextEncoder();
    useUint8Array = (chunk) => new Uint8Array(chunk);
    useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
    addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
      const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
      new Uint8Array(newContents).set(convertedChunk, previousLength);
      return newContents;
    };
    resizeArrayBufferSlow = (contents, length) => {
      if (length <= contents.byteLength) {
        return contents;
      }
      const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
      new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
      return arrayBuffer;
    };
    resizeArrayBuffer = (contents, length) => {
      if (length <= contents.maxByteLength) {
        contents.resize(length);
        return contents;
      }
      const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
      new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
      return arrayBuffer;
    };
    getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
    SCALE_FACTOR = 2;
    finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
    hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;
    arrayBufferMethods = {
      init: initArrayBuffer,
      convertChunk: {
        string: useTextEncoder,
        buffer: useUint8Array,
        arrayBuffer: useUint8Array,
        dataView: useUint8ArrayWithOffset,
        typedArray: useUint8ArrayWithOffset,
        others: throwObjectStream
      },
      getSize: getLengthProp,
      truncateChunk: truncateArrayBufferChunk,
      addChunk: addArrayBufferChunk,
      getFinalChunk: noop,
      finalize: finalizeArrayBuffer
    };
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/buffer.js
async function getStreamAsBuffer(stream, options) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream, options));
  } catch (error) {
    if (error.bufferedData !== void 0) {
      error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
    }
    throw error;
  }
}
var arrayBufferToNodeBuffer;
var init_buffer = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/buffer.js"() {
    "use strict";
    init_array_buffer();
    arrayBufferToNodeBuffer = (arrayBuffer) => globalThis.Buffer.from(arrayBuffer);
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/string.js
async function getStreamAsString(stream, options) {
  return getStreamContents(stream, stringMethods, options);
}
var initString, useTextDecoder, addStringChunk, truncateStringChunk, getFinalStringChunk, stringMethods;
var init_string = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/string.js"() {
    "use strict";
    init_contents();
    init_utils();
    initString = () => ({ contents: "", textDecoder: new TextDecoder() });
    useTextDecoder = (chunk, { textDecoder }) => textDecoder.decode(chunk, { stream: true });
    addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
    truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
    getFinalStringChunk = ({ textDecoder }) => {
      const finalChunk = textDecoder.decode();
      return finalChunk === "" ? void 0 : finalChunk;
    };
    stringMethods = {
      init: initString,
      convertChunk: {
        string: identity,
        buffer: useTextDecoder,
        arrayBuffer: useTextDecoder,
        dataView: useTextDecoder,
        typedArray: useTextDecoder,
        others: throwObjectStream
      },
      getSize: getLengthProp,
      truncateChunk: truncateStringChunk,
      addChunk: addStringChunk,
      getFinalChunk: getFinalStringChunk,
      finalize: getContentsProp
    };
  }
});

// node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/index.js
var init_source = __esm({
  "node_modules/.pnpm/get-stream@8.0.1/node_modules/get-stream/source/index.js"() {
    "use strict";
    init_array();
    init_array_buffer();
    init_buffer();
    init_string();
    init_contents();
  }
});

// node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source) {
        if (Array.isArray(source)) {
          source.forEach(add);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/stream.js
var import_node_fs2, import_promises, import_merge_stream, validateInputOptions, getInputSync, handleInputSync, getInput, handleInput, makeAllStream, getBufferedData, getStreamPromise, applyEncoding, getSpawnedResult;
var init_stream = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/stream.js"() {
    "use strict";
    import_node_fs2 = require("fs");
    import_promises = require("timers/promises");
    init_is_stream();
    init_source();
    import_merge_stream = __toESM(require_merge_stream(), 1);
    validateInputOptions = (input) => {
      if (input !== void 0) {
        throw new TypeError("The `input` and `inputFile` options cannot be both set.");
      }
    };
    getInputSync = ({ input, inputFile }) => {
      if (typeof inputFile !== "string") {
        return input;
      }
      validateInputOptions(input);
      return (0, import_node_fs2.readFileSync)(inputFile);
    };
    handleInputSync = (options) => {
      const input = getInputSync(options);
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      return input;
    };
    getInput = ({ input, inputFile }) => {
      if (typeof inputFile !== "string") {
        return input;
      }
      validateInputOptions(input);
      return (0, import_node_fs2.createReadStream)(inputFile);
    };
    handleInput = (spawned, options) => {
      const input = getInput(options);
      if (input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    makeAllStream = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = (0, import_merge_stream.default)();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    getBufferedData = async (stream, streamPromise) => {
      if (!stream || streamPromise === void 0) {
        return;
      }
      await (0, import_promises.setTimeout)(0);
      stream.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding === "utf8" || encoding === "utf-8") {
        return getStreamAsString(stream, { maxBuffer });
      }
      if (encoding === null || encoding === "buffer") {
        return getStreamAsBuffer(stream, { maxBuffer });
      }
      return applyEncoding(stream, maxBuffer, encoding);
    };
    applyEncoding = async (stream, maxBuffer, encoding) => {
      const buffer = await getStreamAsBuffer(stream, { maxBuffer });
      return buffer.toString(encoding);
    };
    getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/promise.js
var nativePromisePrototype, descriptors, mergePromise, getSpawnedPromise;
var init_promise = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/promise.js"() {
    "use strict";
    nativePromisePrototype = (async () => {
    })().constructor.prototype;
    descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    mergePromise = (spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
    };
    getSpawnedPromise = (spawned) => new Promise((resolve15, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve15({ exitCode, signal });
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/command.js
var import_node_buffer, import_node_child_process2, normalizeArgs, NO_ESCAPE_REGEXP, escapeArg, joinCommand, getEscapedCommand, SPACES_REGEXP, parseCommand, parseExpression, concatTokens, parseTemplate, parseTemplates;
var init_command = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/command.js"() {
    "use strict";
    import_node_buffer = require("buffer");
    import_node_child_process2 = require("child_process");
    normalizeArgs = (file, args = []) => {
      if (!Array.isArray(args)) {
        return [file];
      }
      return [file, ...args];
    };
    NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    escapeArg = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
        return arg;
      }
      return `"${arg.replaceAll('"', '\\"')}"`;
    };
    joinCommand = (file, args) => normalizeArgs(file, args).join(" ");
    getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" ");
    SPACES_REGEXP = / +/g;
    parseCommand = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens.at(-1);
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    parseExpression = (expression) => {
      const typeOfExpression = typeof expression;
      if (typeOfExpression === "string") {
        return expression;
      }
      if (typeOfExpression === "number") {
        return String(expression);
      }
      if (typeOfExpression === "object" && expression !== null && !(expression instanceof import_node_child_process2.ChildProcess) && "stdout" in expression) {
        const typeOfStdout = typeof expression.stdout;
        if (typeOfStdout === "string") {
          return expression.stdout;
        }
        if (import_node_buffer.Buffer.isBuffer(expression.stdout)) {
          return expression.stdout.toString();
        }
        throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
      }
      throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
    };
    concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
      ...tokens.slice(0, -1),
      `${tokens.at(-1)}${nextTokens[0]}`,
      ...nextTokens.slice(1)
    ];
    parseTemplate = ({ templates, expressions, tokens, index, template }) => {
      const templateString = template ?? templates.raw[index];
      const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
      const newTokens = concatTokens(
        tokens,
        templateTokens,
        templateString.startsWith(" ")
      );
      if (index === expressions.length) {
        return newTokens;
      }
      const expression = expressions[index];
      const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
      return concatTokens(
        newTokens,
        expressionTokens,
        templateString.endsWith(" ")
      );
    };
    parseTemplates = (templates, expressions) => {
      let tokens = [];
      for (const [index, template] of templates.entries()) {
        tokens = parseTemplate({ templates, expressions, tokens, index, template });
      }
      return tokens;
    };
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/verbose.js
var import_node_util, import_node_process3, verboseDefault, padField, getTimestamp, logCommand;
var init_verbose = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/lib/verbose.js"() {
    "use strict";
    import_node_util = require("util");
    import_node_process3 = __toESM(require("process"), 1);
    verboseDefault = (0, import_node_util.debuglog)("execa").enabled;
    padField = (field, padding) => String(field).padStart(padding, "0");
    getTimestamp = () => {
      const date = /* @__PURE__ */ new Date();
      return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
    };
    logCommand = (escapedCommand, { verbose }) => {
      if (!verbose) {
        return;
      }
      import_node_process3.default.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
    };
  }
});

// node_modules/.pnpm/execa@8.0.1/node_modules/execa/index.js
var execa_exports = {};
__export(execa_exports, {
  $: () => $,
  execa: () => execa,
  execaCommand: () => execaCommand,
  execaCommandSync: () => execaCommandSync,
  execaNode: () => execaNode,
  execaSync: () => execaSync
});
function execa(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = import_node_child_process3.default.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    const dummySpawned = new import_node_child_process3.default.ChildProcess();
    const errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    mergePromise(dummySpawned, errorPromise);
    return dummySpawned;
  }
  const spawnedPromise = getSpawnedPromise(spawned);
  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromise = async () => {
    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      const returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  const handlePromiseOnce = onetime_default(handlePromise);
  handleInput(spawned, parsed.options);
  spawned.all = makeAllStream(spawned, parsed.options);
  addPipeMethods(spawned);
  mergePromise(spawned, handlePromiseOnce);
  return spawned;
}
function execaSync(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  const input = handleInputSync(parsed.options);
  let result;
  try {
    result = import_node_child_process3.default.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error) {
    throw makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    });
  }
  const stdout = handleOutput(parsed.options, result.stdout, result.error);
  const stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    const error = makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: false,
      killed: result.signal !== null
    });
    if (!parsed.options.reject) {
      return error;
    }
    throw error;
  }
  return {
    command,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: false,
    timedOut: false,
    isCanceled: false,
    killed: false
  };
}
function create$(options) {
  function $2(templatesOrOptions, ...expressions) {
    if (!Array.isArray(templatesOrOptions)) {
      return create$({ ...options, ...templatesOrOptions });
    }
    const [file, ...args] = parseTemplates(templatesOrOptions, expressions);
    return execa(file, args, normalizeScriptOptions(options));
  }
  $2.sync = (templates, ...expressions) => {
    if (!Array.isArray(templates)) {
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    }
    const [file, ...args] = parseTemplates(templates, expressions);
    return execaSync(file, args, normalizeScriptOptions(options));
  };
  return $2;
}
function execaCommand(command, options) {
  const [file, ...args] = parseCommand(command);
  return execa(file, args, options);
}
function execaCommandSync(command, options) {
  const [file, ...args] = parseCommand(command);
  return execaSync(file, args, options);
}
function execaNode(scriptPath, args, options = {}) {
  if (args && !Array.isArray(args) && typeof args === "object") {
    options = args;
    args = [];
  }
  const stdio = normalizeStdioNode(options);
  const defaultExecArgv = import_node_process4.default.execArgv.filter((arg) => !arg.startsWith("--inspect"));
  const {
    nodePath = import_node_process4.default.execPath,
    nodeOptions = defaultExecArgv
  } = options;
  return execa(
    nodePath,
    [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ],
    {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    }
  );
}
var import_node_buffer2, import_node_path13, import_node_child_process3, import_node_process4, import_cross_spawn, DEFAULT_MAX_BUFFER, getEnv, handleArguments, handleOutput, normalizeScriptStdin, normalizeScriptOptions, $;
var init_execa = __esm({
  "node_modules/.pnpm/execa@8.0.1/node_modules/execa/index.js"() {
    "use strict";
    import_node_buffer2 = require("buffer");
    import_node_path13 = __toESM(require("path"), 1);
    import_node_child_process3 = __toESM(require("child_process"), 1);
    import_node_process4 = __toESM(require("process"), 1);
    import_cross_spawn = __toESM(require_cross_spawn(), 1);
    init_strip_final_newline();
    init_npm_run_path();
    init_onetime();
    init_error();
    init_stdio();
    init_kill();
    init_pipe();
    init_stream();
    init_promise();
    init_command();
    init_verbose();
    DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env = extendEnv ? { ...import_node_process4.default.env, ...envOption } : envOption;
      if (preferLocal) {
        return npmRunPathEnv({ env, cwd: localDir, execPath });
      }
      return env;
    };
    handleArguments = (file, args, options = {}) => {
      const parsed = import_cross_spawn.default._parse(file, args, options);
      file = parsed.command;
      args = parsed.args;
      options = parsed.options;
      options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || import_node_process4.default.cwd(),
        execPath: import_node_process4.default.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        verbose: verboseDefault,
        ...options
      };
      options.env = getEnv(options);
      options.stdio = normalizeStdio(options);
      if (import_node_process4.default.platform === "win32" && import_node_path13.default.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return { file, args, options, parsed };
    };
    handleOutput = (options, value, error) => {
      if (typeof value !== "string" && !import_node_buffer2.Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    normalizeScriptStdin = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
    normalizeScriptOptions = (options = {}) => ({
      preferLocal: true,
      ...normalizeScriptStdin(options),
      ...options
    });
    $ = create$();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  build: () => build,
  clean: () => clean,
  createServer: () => createServer,
  defineConfig: () => defineConfig,
  defineRunnerConfig: () => defineRunnerConfig,
  initialize: () => initialize,
  prepare: () => prepare,
  version: () => version,
  zip: () => zip
});
module.exports = __toCommonJS(src_exports);

// src/core/utils/fs.ts
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/core/utils/paths.ts
var import_node_path = __toESM(require("path"), 1);
var import_normalize_path = __toESM(require("normalize-path"), 1);
function normalizePath(path11) {
  return (0, import_normalize_path.default)(path11);
}
function unnormalizePath(path11) {
  return import_node_path.default.normalize(path11);
}
var CSS_EXTENSIONS = ["css", "scss", "sass", "less", "styl", "stylus"];
var CSS_EXTENSIONS_PATTERN = `+(${CSS_EXTENSIONS.join("|")})`;

// src/core/wxt.ts
var import_hookable = require("hookable");
var wxt;
async function registerWxt(command, inlineConfig = {}, server) {
  const config = await resolveConfig(inlineConfig, command, server);
  const hooks = (0, import_hookable.createHooks)();
  wxt = {
    config,
    hooks,
    get logger() {
      return config.logger;
    },
    async reloadConfig() {
      wxt.config = await resolveConfig(inlineConfig, command, server);
    }
  };
  wxt.hooks.addHooks(config.hooks);
  await wxt.hooks.callHook("ready", wxt);
}

// src/core/utils/fs.ts
async function writeFileIfDifferent(file, newContents) {
  const existingContents = await import_fs_extra.default.readFile(file, "utf-8").catch(() => void 0);
  if (existingContents !== newContents) {
    await import_fs_extra.default.writeFile(file, newContents);
  }
}
async function getPublicFiles() {
  if (!await import_fs_extra.default.exists(wxt.config.publicDir))
    return [];
  const files = await (0, import_fast_glob.default)("**/*", { cwd: wxt.config.publicDir });
  return files.map(unnormalizePath);
}

// src/core/utils/building/build-entrypoints.ts
var import_fs_extra2 = __toESM(require("fs-extra"), 1);
var import_path = require("path");
var import_picocolors = __toESM(require("picocolors"), 1);
async function buildEntrypoints(groups, spinner) {
  const steps = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    const groupNames = [group].flat().map((e) => e.name);
    const groupNameColored = groupNames.join(import_picocolors.default.dim(", "));
    spinner.text = import_picocolors.default.dim(`[${i + 1}/${groups.length}]`) + ` ${groupNameColored}`;
    try {
      steps.push(await wxt.config.builder.build(group));
    } catch (err) {
      wxt.logger.error(err);
      throw Error(`Failed to build ${groupNames.join(", ")}`, { cause: err });
    }
  }
  const publicAssets = await copyPublicDirectory();
  return { publicAssets, steps };
}
async function copyPublicDirectory() {
  const files = await getPublicFiles();
  if (files.length === 0)
    return [];
  const publicAssets = [];
  for (const file of files) {
    const srcPath = (0, import_path.resolve)(wxt.config.publicDir, file);
    const outPath = (0, import_path.resolve)(wxt.config.outDir, file);
    await import_fs_extra2.default.ensureDir((0, import_path.dirname)(outPath));
    await import_fs_extra2.default.copyFile(srcPath, outPath);
    publicAssets.push({
      type: "asset",
      fileName: file
    });
  }
  return publicAssets;
}

// src/core/utils/arrays.ts
function every(array, predicate) {
  for (let i = 0; i < array.length; i++)
    if (!predicate(array[i], i))
      return false;
  return true;
}
function some(array, predicate) {
  for (let i = 0; i < array.length; i++)
    if (predicate(array[i], i))
      return true;
  return false;
}

// src/core/utils/building/detect-dev-changes.ts
function detectDevChanges(changedFiles, currentOutput) {
  const isConfigChange = some(
    changedFiles,
    (file) => file === wxt.config.userConfigMetadata.configFile
  );
  if (isConfigChange)
    return { type: "full-restart" };
  const isRunnerChange = some(
    changedFiles,
    (file) => file === wxt.config.runnerConfig.configFile
  );
  if (isRunnerChange)
    return { type: "browser-restart" };
  const changedSteps = new Set(
    changedFiles.flatMap(
      (changedFile) => findEffectedSteps(changedFile, currentOutput)
    )
  );
  if (changedSteps.size === 0)
    return { type: "no-change" };
  const unchangedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  const changedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  for (const step of currentOutput.steps) {
    if (changedSteps.has(step)) {
      changedOutput.steps.push(step);
    } else {
      unchangedOutput.steps.push(step);
    }
  }
  for (const asset of currentOutput.publicAssets) {
    if (changedSteps.has(asset)) {
      changedOutput.publicAssets.push(asset);
    } else {
      unchangedOutput.publicAssets.push(asset);
    }
  }
  const isOnlyHtmlChanges = changedFiles.length > 0 && every(changedFiles, (file) => file.endsWith(".html"));
  if (isOnlyHtmlChanges) {
    return {
      type: "html-reload",
      cachedOutput: unchangedOutput,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  const isOnlyContentScripts = changedOutput.steps.length > 0 && every(
    changedOutput.steps.flatMap((step) => step.entrypoints),
    (entry) => entry.type === "content-script"
  );
  if (isOnlyContentScripts) {
    return {
      type: "content-script-reload",
      cachedOutput: unchangedOutput,
      changedSteps: changedOutput.steps,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  return {
    type: "extension-reload",
    cachedOutput: unchangedOutput,
    rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
  };
}
function findEffectedSteps(changedFile, currentOutput) {
  const changes = [];
  const changedPath = normalizePath(changedFile);
  const isChunkEffected = (chunk) => (
    // If it's an HTML file with the same path, is is effected because HTML files need to be re-rendered
    // - fileName is normalized, relative bundle path, "<entrypoint-name>.html"
    chunk.type === "asset" && changedPath.replace("/index.html", ".html").endsWith(chunk.fileName) || // If it's a chunk that depends on the changed file, it is effected
    // - moduleIds are absolute, normalized paths
    chunk.type === "chunk" && chunk.moduleIds.includes(changedPath)
  );
  for (const step of currentOutput.steps) {
    const effectedChunk = step.chunks.find((chunk) => isChunkEffected(chunk));
    if (effectedChunk)
      changes.push(step);
  }
  const effectedAsset = currentOutput.publicAssets.find(
    (chunk) => isChunkEffected(chunk)
  );
  if (effectedAsset)
    changes.push(effectedAsset);
  return changes;
}

// src/core/utils/building/find-entrypoints.ts
var import_path2 = require("path");
var import_fs_extra3 = __toESM(require("fs-extra"), 1);
var import_minimatch = require("minimatch");
var import_linkedom = require("linkedom");
var import_json5 = __toESM(require("json5"), 1);
var import_fast_glob2 = __toESM(require("fast-glob"), 1);

// src/core/utils/entrypoints.ts
var import_node_path2 = __toESM(require("path"), 1);
function getEntrypointName(entrypointsDir, inputPath) {
  const relativePath = import_node_path2.default.relative(entrypointsDir, inputPath);
  const name = relativePath.split(/[\.\/\\]/, 2)[0];
  return name;
}
function getEntrypointOutputFile(entrypoint, ext) {
  return (0, import_node_path2.resolve)(entrypoint.outputDir, `${entrypoint.name}${ext}`);
}
function getEntrypointBundlePath(entrypoint, outDir, ext) {
  return normalizePath(
    (0, import_node_path2.relative)(outDir, getEntrypointOutputFile(entrypoint, ext))
  );
}
function resolvePerBrowserOption(option, browser) {
  if (typeof option === "object" && !Array.isArray(option))
    return option[browser];
  return option;
}
function resolvePerBrowserOptions(options, browser) {
  return Object.fromEntries(
    Object.entries(options).map(([key, value]) => [
      key,
      key === "defaultIcon" ? value : resolvePerBrowserOption(value, browser)
    ])
  );
}
function isHtmlEntrypoint(entrypoint) {
  return entrypoint.inputPath.endsWith(".html");
}

// src/core/utils/constants.ts
var VIRTUAL_NOOP_BACKGROUND_MODULE_ID = "virtual:user-background";

// src/core/utils/building/find-entrypoints.ts
var import_picocolors2 = __toESM(require("picocolors"), 1);
async function findEntrypoints() {
  const relativePaths = await (0, import_fast_glob2.default)(Object.keys(PATH_GLOB_TO_TYPE_MAP), {
    cwd: wxt.config.entrypointsDir
  });
  relativePaths.sort();
  const pathGlobs = Object.keys(PATH_GLOB_TO_TYPE_MAP);
  const entrypointInfos = relativePaths.reduce((results, relativePath) => {
    const inputPath = (0, import_path2.resolve)(wxt.config.entrypointsDir, relativePath);
    const name = getEntrypointName(wxt.config.entrypointsDir, inputPath);
    const matchingGlob = pathGlobs.find(
      (glob5) => (0, import_minimatch.minimatch)(relativePath, glob5)
    );
    if (matchingGlob) {
      const type = PATH_GLOB_TO_TYPE_MAP[matchingGlob];
      results.push({
        name,
        inputPath,
        type,
        skipped: wxt.config.filterEntrypoints != null && !wxt.config.filterEntrypoints.has(name)
      });
    }
    return results;
  }, []);
  preventNoEntrypoints(entrypointInfos);
  preventDuplicateEntrypointNames(entrypointInfos);
  let hasBackground = false;
  const entrypoints = await Promise.all(
    entrypointInfos.map(async (info) => {
      const { type } = info;
      switch (type) {
        case "popup":
          return await getPopupEntrypoint(info);
        case "sidepanel":
          return await getSidepanelEntrypoint(info);
        case "options":
          return await getOptionsEntrypoint(info);
        case "background":
          hasBackground = true;
          return await getBackgroundEntrypoint(info);
        case "content-script":
          return await getContentScriptEntrypoint(info);
        case "unlisted-page":
          return await getUnlistedPageEntrypoint(info);
        case "unlisted-script":
          return await getUnlistedScriptEntrypoint(info);
        case "content-script-style":
          return {
            ...info,
            type,
            outputDir: (0, import_path2.resolve)(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
            options: {
              include: void 0,
              exclude: void 0
            }
          };
        default:
          return {
            ...info,
            type,
            outputDir: wxt.config.outDir,
            options: {
              include: void 0,
              exclude: void 0
            }
          };
      }
    })
  );
  if (wxt.config.command === "serve" && !hasBackground) {
    entrypoints.push(
      await getBackgroundEntrypoint({
        inputPath: VIRTUAL_NOOP_BACKGROUND_MODULE_ID,
        name: "background",
        type: "background",
        skipped: false
      })
    );
  }
  wxt.logger.debug("All entrypoints:", entrypoints);
  const skippedEntrypointNames = entrypointInfos.filter((item) => item.skipped).map((item) => item.name);
  if (skippedEntrypointNames.length) {
    wxt.logger.warn(
      `Filter excluded the following entrypoints:
${skippedEntrypointNames.map((item) => `${import_picocolors2.default.dim("-")} ${import_picocolors2.default.cyan(item)}`).join("\n")}`
    );
  }
  const targetEntrypoints = entrypoints.filter((entry) => {
    const { include, exclude } = entry.options;
    if (include?.length && exclude?.length) {
      wxt.logger.warn(
        `The ${entry.name} entrypoint lists both include and exclude, but only one can be used per entrypoint. Entrypoint ignored.`
      );
      return false;
    }
    if (exclude?.length && !include?.length) {
      return !exclude.includes(wxt.config.browser);
    }
    if (include?.length && !exclude?.length) {
      return include.includes(wxt.config.browser);
    }
    if (skippedEntrypointNames.includes(entry.name)) {
      return false;
    }
    return true;
  });
  wxt.logger.debug(`${wxt.config.browser} entrypoints:`, targetEntrypoints);
  await wxt.hooks.callHook("entrypoints:resolved", wxt, targetEntrypoints);
  return targetEntrypoints;
}
function preventDuplicateEntrypointNames(files) {
  const namesToPaths = files.reduce(
    (map, { name, inputPath }) => {
      map[name] ??= [];
      map[name].push(inputPath);
      return map;
    },
    {}
  );
  const errorLines = Object.entries(namesToPaths).reduce(
    (lines, [name, absolutePaths]) => {
      if (absolutePaths.length > 1) {
        lines.push(`- ${name}`);
        absolutePaths.forEach((absolutePath) => {
          lines.push(`  - ${(0, import_path2.relative)(wxt.config.root, absolutePath)}`);
        });
      }
      return lines;
    },
    []
  );
  if (errorLines.length > 0) {
    const errorContent = errorLines.join("\n");
    throw Error(
      `Multiple entrypoints with the same name detected, only one entrypoint for each name is allowed.

${errorContent}`
    );
  }
}
function preventNoEntrypoints(files) {
  if (files.length === 0) {
    throw Error(`No entrypoints found in ${wxt.config.entrypointsDir}`);
  }
}
async function getPopupEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      mv2Key: "type"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content,
      mv2Key: (content) => content === "page_action" ? "page_action" : "browser_action"
    }
  );
  return {
    type: "popup",
    name: "popup",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getOptionsEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      chromeStyle: "chrome_style",
      exclude: "exclude",
      include: "include",
      openInTab: "open_in_tab"
    }
  );
  return {
    type: "options",
    name: "options",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getUnlistedPageEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(info, {
    exclude: "exclude",
    include: "include"
  });
  return {
    type: "unlisted-page",
    name: info.name,
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    options,
    skipped: info.skipped
  };
}
async function getUnlistedScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const defaultExport = await importEntrypointFile(inputPath);
  if (defaultExport == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineUnlistedScript(...)"?`
    );
  }
  const { main: _, ...options } = defaultExport;
  return {
    type: "unlisted-script",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getBackgroundEntrypoint({
  inputPath,
  name,
  skipped
}) {
  let options = {};
  if (inputPath !== VIRTUAL_NOOP_BACKGROUND_MODULE_ID) {
    const defaultExport = await importEntrypointFile(inputPath);
    if (defaultExport == null) {
      throw Error(
        `${name}: Default export not found, did you forget to call "export default defineBackground(...)"?`
      );
    }
    const { main: _, ...moduleOptions } = defaultExport;
    options = moduleOptions;
  }
  if (wxt.config.manifestVersion !== 3) {
    delete options.type;
  }
  return {
    type: "background",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getContentScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const { main: _, ...options } = await importEntrypointFile(inputPath);
  if (options == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineContentScript(...)"?`
    );
  }
  return {
    type: "content-script",
    name,
    inputPath,
    outputDir: (0, import_path2.resolve)(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getSidepanelEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      openAtInstall: "open_at_install"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content
    }
  );
  return {
    type: "sidepanel",
    name: info.name,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getHtmlEntrypointOptions(info, keyMap, queries, parsers) {
  const content = await import_fs_extra3.default.readFile(info.inputPath, "utf-8");
  const { document } = (0, import_linkedom.parseHTML)(content);
  const options = {};
  const defaultQuery = (manifestKey) => document.querySelector(`meta[name='manifest.${manifestKey}']`)?.getAttribute("content");
  Object.entries(keyMap).forEach(([_key, manifestKey]) => {
    const key = _key;
    const content2 = queries?.[key] ? queries[key](document, manifestKey) : defaultQuery(manifestKey);
    if (content2) {
      try {
        options[key] = (parsers?.[key] ?? import_json5.default.parse)(content2);
      } catch (err) {
        wxt.logger.fatal(
          `Failed to parse meta tag content. Usually this means you have invalid JSON5 content (content=${content2})`,
          err
        );
      }
    }
  });
  return options;
}
var PATH_GLOB_TO_TYPE_MAP = {
  "sandbox.html": "sandbox",
  "sandbox/index.html": "sandbox",
  "*.sandbox.html": "sandbox",
  "*.sandbox/index.html": "sandbox",
  "bookmarks.html": "bookmarks",
  "bookmarks/index.html": "bookmarks",
  "history.html": "history",
  "history/index.html": "history",
  "newtab.html": "newtab",
  "newtab/index.html": "newtab",
  "sidepanel.html": "sidepanel",
  "sidepanel/index.html": "sidepanel",
  "*.sidepanel.html": "sidepanel",
  "*.sidepanel/index.html": "sidepanel",
  "devtools.html": "devtools",
  "devtools/index.html": "devtools",
  "background.[jt]s": "background",
  "background/index.[jt]s": "background",
  [VIRTUAL_NOOP_BACKGROUND_MODULE_ID]: "background",
  "content.[jt]s?(x)": "content-script",
  "content/index.[jt]s?(x)": "content-script",
  "*.content.[jt]s?(x)": "content-script",
  "*.content/index.[jt]s?(x)": "content-script",
  [`content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  "popup.html": "popup",
  "popup/index.html": "popup",
  "options.html": "options",
  "options/index.html": "options",
  "*.html": "unlisted-page",
  "*/index.html": "unlisted-page",
  "*.[jt]s?(x)": "unlisted-script",
  "*/index.[jt]s?(x)": "unlisted-script",
  [`*.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style",
  [`*/index.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style"
};
var CONTENT_SCRIPT_OUT_DIR = "content-scripts";

// src/core/utils/building/generate-wxt-dir.ts
var import_unimport = require("unimport");
var import_fs_extra4 = __toESM(require("fs-extra"), 1);
var import_path3 = require("path");

// src/core/utils/globals.ts
function getGlobals(config) {
  return [
    {
      name: "MANIFEST_VERSION",
      value: config.manifestVersion,
      type: `2 | 3`
    },
    {
      name: "BROWSER",
      value: config.browser,
      type: `string`
    },
    {
      name: "CHROME",
      value: config.browser === "chrome",
      type: `boolean`
    },
    {
      name: "FIREFOX",
      value: config.browser === "firefox",
      type: `boolean`
    },
    {
      name: "SAFARI",
      value: config.browser === "safari",
      type: `boolean`
    },
    {
      name: "EDGE",
      value: config.browser === "edge",
      type: `boolean`
    },
    {
      name: "OPERA",
      value: config.browser === "opera",
      type: `boolean`
    },
    {
      name: "COMMAND",
      value: config.command,
      type: `"build" | "serve"`
    }
  ];
}
function getEntrypointGlobals(entrypointName) {
  return [
    {
      name: "ENTRYPOINT",
      value: entrypointName,
      type: `string`
    }
  ];
}

// src/core/utils/building/generate-wxt-dir.ts
var import_node_path3 = __toESM(require("path"), 1);

// src/core/utils/i18n.ts
var predefinedMessages = {
  "@@extension_id": {
    message: "<browser.runtime.id>",
    description: "The extension or app ID; you might use this string to construct URLs for resources inside the extension. Even unlocalized extensions can use this message.\nNote: You can't use this message in a manifest file."
  },
  "@@ui_locale": {
    message: "<browser.i18n.getUiLocale()>",
    description: ""
  },
  "@@bidi_dir": {
    message: "<ltr|rtl>",
    description: 'The text direction for the current locale, either "ltr" for left-to-right languages such as English or "rtl" for right-to-left languages such as Japanese.'
  },
  "@@bidi_reversed_dir": {
    message: "<rtl|ltr>",
    description: `If the @@bidi_dir is "ltr", then this is "rtl"; otherwise, it's "ltr".`
  },
  "@@bidi_start_edge": {
    message: "<left|right>",
    description: `If the @@bidi_dir is "ltr", then this is "left"; otherwise, it's "right".`
  },
  "@@bidi_end_edge": {
    message: "<right|left>",
    description: `If the @@bidi_dir is "ltr", then this is "right"; otherwise, it's "left".`
  }
};
function parseI18nMessages(messagesJson) {
  return Object.entries({
    ...predefinedMessages,
    ...messagesJson
  }).map(([name, details]) => ({
    name,
    ...details
  }));
}

// src/core/utils/building/generate-wxt-dir.ts
async function generateTypesDir(entrypoints) {
  await import_fs_extra4.default.ensureDir(wxt.config.typesDir);
  const references = [];
  if (wxt.config.imports !== false) {
    const unimport2 = (0, import_unimport.createUnimport)(wxt.config.imports);
    references.push(await writeImportsDeclarationFile(unimport2));
    if (wxt.config.imports.eslintrc.enabled) {
      await writeImportsEslintFile(unimport2, wxt.config.imports);
    }
  }
  references.push(await writePathsDeclarationFile(entrypoints));
  references.push(await writeI18nDeclarationFile());
  references.push(await writeGlobalsDeclarationFile());
  const mainReference = await writeMainDeclarationFile(references);
  await writeTsConfigFile(mainReference);
}
async function writeImportsDeclarationFile(unimport2) {
  const filePath = (0, import_path3.resolve)(wxt.config.typesDir, "imports.d.ts");
  await unimport2.scanImportsFromDir(void 0, { cwd: wxt.config.srcDir });
  await writeFileIfDifferent(
    filePath,
    ["// Generated by wxt", await unimport2.generateTypeDeclarations()].join(
      "\n"
    ) + "\n"
  );
  return filePath;
}
async function writeImportsEslintFile(unimport2, options) {
  const globals2 = {};
  const eslintrc = { globals: globals2 };
  (await unimport2.getImports()).map((i) => i.as ?? i.name).filter(Boolean).sort().forEach((name) => {
    eslintrc.globals[name] = options.eslintrc.globalsPropValue;
  });
  await import_fs_extra4.default.writeJson(options.eslintrc.filePath, eslintrc, { spaces: 2 });
}
async function writePathsDeclarationFile(entrypoints) {
  const filePath = (0, import_path3.resolve)(wxt.config.typesDir, "paths.d.ts");
  const unions = entrypoints.map(
    (entry) => getEntrypointBundlePath(
      entry,
      wxt.config.outDir,
      isHtmlEntrypoint(entry) ? ".html" : ".js"
    )
  ).concat(await getPublicFiles()).map(normalizePath).map((path11) => `    | "/${path11}"`).sort().join("\n");
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  export type PublicPath =
{{ union }}
  type HtmlPublicPath = Extract<PublicPath, \`\${string}.html\`>
  export interface WxtRuntime extends Runtime.Static {
    getURL(path: PublicPath): string;
    getURL(path: \`\${HtmlPublicPath}\${string}\`): string;
  }
}
`;
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ union }}", unions || "    | never")
  );
  return filePath;
}
async function writeI18nDeclarationFile() {
  const filePath = (0, import_path3.resolve)(wxt.config.typesDir, "i18n.d.ts");
  const defaultLocale = wxt.config.manifest.default_locale;
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  /**
   * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
   */
  interface GetMessageOptions {
    /**
     * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
     */
    escapeLt?: boolean
  }

  export interface WxtI18n extends I18n.Static {
{{ overrides }}
  }
}
`;
  let messages;
  if (defaultLocale) {
    const defaultLocalePath = import_node_path3.default.resolve(
      wxt.config.publicDir,
      "_locales",
      defaultLocale,
      "messages.json"
    );
    const content = JSON.parse(await import_fs_extra4.default.readFile(defaultLocalePath, "utf-8"));
    messages = parseI18nMessages(content);
  } else {
    messages = parseI18nMessages({});
  }
  const overrides = messages.map((message) => {
    return `    /**
     * ${message.description || "No message description."}
     *
     * "${message.message}"
     */
    getMessage(
      messageName: "${message.name}",
      substitutions?: string | string[],
      options?: GetMessageOptions,
    ): string;`;
  });
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ overrides }}", overrides.join("\n"))
  );
  return filePath;
}
async function writeGlobalsDeclarationFile() {
  const filePath = (0, import_path3.resolve)(wxt.config.typesDir, "globals.d.ts");
  const globals2 = [...getGlobals(wxt.config), ...getEntrypointGlobals("")];
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      "export {}",
      "interface ImportMetaEnv {",
      ...globals2.map((global3) => `  readonly ${global3.name}: ${global3.type};`),
      "}",
      "interface ImportMeta {",
      "  readonly env: ImportMetaEnv",
      "}"
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeMainDeclarationFile(references) {
  const dir = wxt.config.wxtDir;
  const filePath = (0, import_path3.resolve)(dir, "wxt.d.ts");
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      `/// <reference types="wxt/vite-builder-env" />`,
      ...references.map(
        (ref) => `/// <reference types="./${normalizePath((0, import_path3.relative)(dir, ref))}" />`
      )
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeTsConfigFile(mainReference) {
  const dir = wxt.config.wxtDir;
  const getTsconfigPath = (path11) => normalizePath((0, import_path3.relative)(dir, path11));
  const paths = Object.entries(wxt.config.alias).flatMap(([alias, absolutePath]) => {
    const aliasPath = getTsconfigPath(absolutePath);
    return [
      `      "${alias}": ["${aliasPath}"]`,
      `      "${alias}/*": ["${aliasPath}/*"]`
    ];
  }).join(",\n");
  await writeFileIfDifferent(
    (0, import_path3.resolve)(dir, "tsconfig.json"),
    `{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "noEmit": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "paths": {
${paths}
    }
  },
  "include": [
    "${getTsconfigPath(wxt.config.root)}/**/*",
    "./${getTsconfigPath(mainReference)}"
  ],
  "exclude": ["${getTsconfigPath(wxt.config.outBaseDir)}"]
}`
  );
}

// src/core/utils/building/resolve-config.ts
var import_c12 = require("c12");
var import_node_path9 = __toESM(require("path"), 1);

// src/core/utils/cache.ts
var import_fs_extra5 = __toESM(require("fs-extra"), 1);
var import_path4 = require("path");
function createFsCache(wxtDir) {
  const getPath = (key) => (0, import_path4.resolve)(wxtDir, "cache", encodeURIComponent(key));
  return {
    async set(key, value) {
      const path11 = getPath(key);
      await (0, import_fs_extra5.ensureDir)((0, import_path4.dirname)(path11));
      await writeFileIfDifferent(path11, value);
    },
    async get(key) {
      const path11 = getPath(key);
      try {
        return await import_fs_extra5.default.readFile(path11, "utf-8");
      } catch {
        return void 0;
      }
    }
  };
}

// src/core/utils/building/resolve-config.ts
var import_consola = __toESM(require("consola"), 1);

// src/core/builders/vite/plugins/devHtmlPrerender.ts
var import_linkedom2 = require("linkedom");
var import_node_path4 = require("path");
var reactRefreshPreamble = "";
function devHtmlPrerender(config) {
  const htmlReloadId = "@wxt/reload-html";
  const resolvedHtmlReloadId = (0, import_node_path4.resolve)(
    config.root,
    "node_modules/wxt/dist/virtual/reload-html.js"
  );
  const virtualReactRefreshId = "@wxt/virtual-react-refresh";
  const resolvedVirtualReactRefreshId = "\0" + virtualReactRefreshId;
  return [
    {
      apply: "build",
      name: "wxt:dev-html-prerender",
      config() {
        return {
          resolve: {
            alias: {
              [htmlReloadId]: resolvedHtmlReloadId
            }
          }
        };
      },
      // Convert scripts like src="./main.tsx" -> src="http://localhost:3000/entrypoints/popup/main.tsx"
      // before the paths are replaced with their bundled path
      transform(code, id) {
        const server = config.server;
        if (config.command !== "serve" || server == null || !id.endsWith(".html"))
          return;
        const { document } = (0, import_linkedom2.parseHTML)(code);
        const _pointToDevServer = (querySelector, attr) => pointToDevServer(config, server, id, document, querySelector, attr);
        _pointToDevServer("script[type=module]", "src");
        _pointToDevServer("link[rel=stylesheet]", "href");
        const reloader = document.createElement("script");
        reloader.src = htmlReloadId;
        reloader.type = "module";
        document.head.appendChild(reloader);
        const newHtml = document.toString();
        config.logger.debug("transform " + id);
        config.logger.debug("Old HTML:\n" + code);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      },
      // Pass the HTML through the dev server to add dev-mode specific code
      async transformIndexHtml(html, ctx) {
        const server = config.server;
        if (config.command !== "serve" || server == null)
          return;
        const originalUrl = `${server.origin}${ctx.path}`;
        const name = getEntrypointName(config.entrypointsDir, ctx.filename);
        const url2 = `${server.origin}/${name}.html`;
        const serverHtml = await server.transformHtml(url2, html, originalUrl);
        const { document } = (0, import_linkedom2.parseHTML)(serverHtml);
        const reactRefreshScript = Array.from(
          document.querySelectorAll("script[type=module]")
        ).find((script) => script.innerHTML.includes("@react-refresh"));
        if (reactRefreshScript) {
          reactRefreshPreamble = reactRefreshScript.innerHTML;
          const virtualScript = document.createElement("script");
          virtualScript.type = "module";
          virtualScript.src = `${server.origin}/${virtualReactRefreshId}`;
          reactRefreshScript.replaceWith(virtualScript);
        }
        const viteClientScript = document.querySelector(
          "script[src='/@vite/client']"
        );
        if (viteClientScript) {
          viteClientScript.src = `${server.origin}${viteClientScript.src}`;
        }
        const newHtml = document.toString();
        config.logger.debug("transformIndexHtml " + ctx.filename);
        config.logger.debug("Old HTML:\n" + html);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      }
    },
    {
      name: "wxt:virtualize-react-refresh",
      apply: "serve",
      resolveId(id) {
        if (id === `/${virtualReactRefreshId}`) {
          return resolvedVirtualReactRefreshId;
        }
        if (id.startsWith("/chunks/")) {
          return "\0noop";
        }
      },
      load(id) {
        if (id === resolvedVirtualReactRefreshId) {
          return reactRefreshPreamble;
        }
        if (id === "\0noop") {
          return "";
        }
      }
    }
  ];
}
function pointToDevServer(config, server, id, document, querySelector, attr) {
  document.querySelectorAll(querySelector).forEach((element) => {
    const src = element.getAttribute(attr);
    if (!src || isUrl(src))
      return;
    let resolvedAbsolutePath;
    const matchingAlias = Object.entries(config.alias).find(
      ([key]) => src.startsWith(key)
    );
    if (matchingAlias) {
      const [alias, replacement] = matchingAlias;
      resolvedAbsolutePath = (0, import_node_path4.resolve)(
        config.root,
        src.replace(alias, replacement)
      );
    } else {
      resolvedAbsolutePath = (0, import_node_path4.resolve)((0, import_node_path4.dirname)(id), src);
    }
    if (resolvedAbsolutePath) {
      const relativePath = normalizePath(
        (0, import_node_path4.relative)(config.root, resolvedAbsolutePath)
      );
      if (relativePath.startsWith(".")) {
        let path11 = normalizePath(resolvedAbsolutePath);
        if (!path11.startsWith("/"))
          path11 = "/" + path11;
        element.setAttribute(attr, `${server.origin}/@fs${path11}`);
      } else {
        const url2 = new URL(relativePath, server.origin);
        element.setAttribute(attr, url2.href);
      }
    }
  });
}
function isUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}

// src/core/builders/vite/plugins/devServerGlobals.ts
function devServerGlobals(config) {
  return {
    name: "wxt:dev-server-globals",
    config() {
      if (config.server == null || config.command == "build")
        return;
      return {
        define: {
          __DEV_SERVER_PROTOCOL__: JSON.stringify("ws:"),
          __DEV_SERVER_HOSTNAME__: JSON.stringify(config.server.hostname),
          __DEV_SERVER_PORT__: JSON.stringify(config.server.port)
        }
      };
    }
  };
}

// src/core/utils/network.ts
var import_node_dns = __toESM(require("dns"), 1);

// src/core/utils/time.ts
function formatDuration(duration) {
  if (duration < 1e3)
    return `${duration} ms`;
  if (duration < 1e4)
    return `${(duration / 1e3).toFixed(3)} s`;
  if (duration < 6e4)
    return `${(duration / 1e3).toFixed(1)} s`;
  return `${(duration / 1e3).toFixed(0)} s`;
}
function withTimeout(promise, duration) {
  return new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      rej(`Promise timed out after ${duration}ms`);
    }, duration);
    promise.then(res).catch(rej).finally(() => clearTimeout(timeout));
  });
}

// src/core/utils/network.ts
function isOffline() {
  const isOffline2 = new Promise((res) => {
    import_node_dns.default.resolve("google.com", (err) => {
      if (err == null) {
        res(false);
      } else {
        res(true);
      }
    });
  });
  return withTimeout(isOffline2, 1e3).catch(() => true);
}
async function isOnline() {
  const offline = await isOffline();
  return !offline;
}
async function fetchCached(url2, config) {
  let content = "";
  if (await isOnline()) {
    const res = await fetch(url2);
    if (res.status < 300) {
      content = await res.text();
      await config.fsCache.set(url2, content);
    } else {
      config.logger.debug(
        `Failed to download "${url2}", falling back to cache...`
      );
    }
  }
  if (!content)
    content = await config.fsCache.get(url2) ?? "";
  if (!content)
    throw Error(
      `Offline and "${url2}" has not been cached. Try again when online.`
    );
  return content;
}

// src/core/builders/vite/plugins/download.ts
function download(config) {
  return {
    name: "wxt:download",
    resolveId(id) {
      if (id.startsWith("url:"))
        return "\0" + id;
    },
    async load(id) {
      if (!id.startsWith("\0url:"))
        return;
      const url2 = id.replace("\0url:", "");
      return await fetchCached(url2, config);
    }
  };
}

// src/core/builders/vite/plugins/multipageMove.ts
var import_node_path5 = require("path");
var import_fs_extra6 = __toESM(require("fs-extra"), 1);
function multipageMove(entrypoints, config) {
  return {
    name: "wxt:multipage-move",
    async writeBundle(_, bundle) {
      for (const oldBundlePath in bundle) {
        const entrypoint = entrypoints.find(
          (entry) => !!normalizePath(entry.inputPath).endsWith(oldBundlePath)
        );
        if (entrypoint == null) {
          config.logger.debug(
            `No entrypoint found for ${oldBundlePath}, leaving in chunks directory`
          );
          continue;
        }
        const newBundlePath = getEntrypointBundlePath(
          entrypoint,
          config.outDir,
          (0, import_node_path5.extname)(oldBundlePath)
        );
        if (newBundlePath === oldBundlePath) {
          config.logger.debug(
            "HTML file is already in the correct location",
            oldBundlePath
          );
          continue;
        }
        const oldAbsPath = (0, import_node_path5.resolve)(config.outDir, oldBundlePath);
        const newAbsPath = (0, import_node_path5.resolve)(config.outDir, newBundlePath);
        await (0, import_fs_extra6.ensureDir)((0, import_node_path5.dirname)(newAbsPath));
        await import_fs_extra6.default.move(oldAbsPath, newAbsPath, { overwrite: true });
        const renamedChunk = {
          ...bundle[oldBundlePath],
          fileName: newBundlePath
        };
        delete bundle[oldBundlePath];
        bundle[newBundlePath] = renamedChunk;
      }
      removeEmptyDirs(config.outDir);
    }
  };
}
async function removeEmptyDirs(dir) {
  const files = await import_fs_extra6.default.readdir(dir);
  for (const file of files) {
    const filePath = (0, import_node_path5.join)(dir, file);
    const stats = await import_fs_extra6.default.stat(filePath);
    if (stats.isDirectory()) {
      await removeEmptyDirs(filePath);
    }
  }
  try {
    await import_fs_extra6.default.rmdir(dir);
  } catch {
  }
}

// src/core/builders/vite/plugins/unimport.ts
var import_unimport2 = require("unimport");
var import_path5 = require("path");
var ENABLED_EXTENSIONS = /* @__PURE__ */ new Set([
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".vue",
  ".svelte"
]);
function unimport(config) {
  const options = config.imports;
  if (options === false)
    return [];
  const unimport2 = (0, import_unimport2.createUnimport)(options);
  return {
    name: "wxt:unimport",
    async config() {
      await unimport2.scanImportsFromDir(void 0, { cwd: config.srcDir });
    },
    async transform(code, id) {
      if (id.includes("node_modules"))
        return;
      if (!ENABLED_EXTENSIONS.has((0, import_path5.extname)(id)))
        return;
      const injected = await unimport2.injectImports(code, id);
      return {
        code: injected.code,
        map: injected.s.generateMap({ hires: "boundary", source: id })
      };
    }
  };
}

// src/core/builders/vite/plugins/virtualEntrypoint.ts
var import_fs_extra7 = __toESM(require("fs-extra"), 1);
var import_path6 = require("path");
function virtualEntrypoint(type, config) {
  const virtualId = `virtual:wxt-${type}?`;
  const resolvedVirtualId = `\0${virtualId}`;
  return {
    name: `wxt:virtual-entrypoint`,
    resolveId(id) {
      const index = id.indexOf(virtualId);
      if (index === -1)
        return;
      const inputPath = normalizePath(id.substring(index + virtualId.length));
      return resolvedVirtualId + inputPath;
    },
    async load(id) {
      if (!id.startsWith(resolvedVirtualId))
        return;
      const inputPath = id.replace(resolvedVirtualId, "");
      const template = await import_fs_extra7.default.readFile(
        (0, import_path6.resolve)(
          config.root,
          `node_modules/wxt/dist/virtual/${type}-entrypoint.js`
        ),
        "utf-8"
      );
      return template.replace(`virtual:user-${type}`, inputPath);
    }
  };
}

// src/core/builders/vite/plugins/tsconfigPaths.ts
function tsconfigPaths(config) {
  return {
    name: "wxt:aliases",
    async config() {
      return {
        resolve: {
          alias: config.alias
        }
      };
    }
  };
}

// src/core/builders/vite/plugins/noopBackground.ts
function noopBackground() {
  const virtualModuleId = VIRTUAL_NOOP_BACKGROUND_MODULE_ID;
  const resolvedVirtualModuleId = "\0" + virtualModuleId;
  return {
    name: "wxt:noop-background",
    resolveId(id) {
      if (id === virtualModuleId)
        return resolvedVirtualModuleId;
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `import { defineBackground } from 'wxt/sandbox';
export default defineBackground(() => void 0)`;
      }
    }
  };
}

// src/core/builders/vite/plugins/cssEntrypoints.ts
function cssEntrypoints(entrypoint, config) {
  return {
    name: "wxt:css-entrypoint",
    config() {
      return {
        build: {
          rollupOptions: {
            output: {
              assetFileNames: () => getEntrypointBundlePath(entrypoint, config.outDir, ".css")
            }
          }
        }
      };
    },
    generateBundle(_, bundle) {
      Object.keys(bundle).forEach((file) => {
        if (file.endsWith(".js"))
          delete bundle[file];
      });
    }
  };
}

// src/core/builders/vite/plugins/bundleAnalysis.ts
var import_rollup_plugin_visualizer = require("rollup-plugin-visualizer");
var import_node_path6 = __toESM(require("path"), 1);
var increment = 0;
function bundleAnalysis(config) {
  return (0, import_rollup_plugin_visualizer.visualizer)({
    template: "raw-data",
    filename: import_node_path6.default.resolve(
      config.analysis.outputDir,
      `${config.analysis.outputName}-${increment++}.json`
    )
  });
}

// src/core/builders/vite/plugins/globals.ts
function globals(config) {
  return {
    name: "wxt:globals",
    config() {
      const define = {};
      for (const global3 of getGlobals(config)) {
        define[`import.meta.env.${global3.name}`] = JSON.stringify(global3.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/webextensionPolyfillMock.ts
var import_node_path7 = __toESM(require("path"), 1);

// src/core/builders/vite/plugins/excludeBrowserPolyfill.ts
function excludeBrowserPolyfill(config) {
  const virtualId = "virtual:wxt-webextension-polyfill-disabled";
  return {
    name: "wxt:exclude-browser-polyfill",
    config() {
      if (config.experimental.includeBrowserPolyfill)
        return;
      return {
        resolve: {
          alias: {
            "webextension-polyfill": virtualId
          }
        }
      };
    },
    load(id) {
      if (id === virtualId) {
        return "export default chrome";
      }
    }
  };
}

// src/core/builders/vite/plugins/entrypointGroupGlobals.ts
function entrypointGroupGlobals(entrypointGroup) {
  return {
    name: "wxt:entrypoint-group-globals",
    config() {
      const define = {};
      let name = Array.isArray(entrypointGroup) ? "html" : entrypointGroup.name;
      for (const global3 of getEntrypointGlobals(name)) {
        define[`import.meta.env.${global3.name}`] = JSON.stringify(global3.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/defineImportMeta.ts
function defineImportMeta() {
  return {
    name: "wxt:define",
    config() {
      return {
        define: {
          // This works for all extension contexts, including background service worker
          "import.meta.url": "self.location.href"
        }
      };
    }
  };
}

// src/core/builders/vite/index.ts
async function createViteBuilder(inlineConfig, userConfig, wxtConfig) {
  const vite = await import("vite");
  const getBaseConfig = async () => {
    const resolvedInlineConfig = await inlineConfig.vite?.(wxtConfig.env) ?? {};
    const resolvedUserConfig = await userConfig.vite?.(wxtConfig.env) ?? {};
    const config = vite.mergeConfig(
      resolvedUserConfig,
      resolvedInlineConfig
    );
    config.root = wxtConfig.root;
    config.configFile = false;
    config.logLevel = "warn";
    config.mode = wxtConfig.mode;
    config.build ??= {};
    config.build.outDir = wxtConfig.outDir;
    config.build.emptyOutDir = false;
    if (config.build.minify == null && wxtConfig.command === "serve") {
      config.build.minify = false;
    }
    if (config.build.sourcemap == null && wxtConfig.command === "serve") {
      config.build.sourcemap = "inline";
    }
    config.plugins ??= [];
    config.plugins.push(
      download(wxtConfig),
      devHtmlPrerender(wxtConfig),
      unimport(wxtConfig),
      virtualEntrypoint("background", wxtConfig),
      virtualEntrypoint("content-script-isolated-world", wxtConfig),
      virtualEntrypoint("content-script-main-world", wxtConfig),
      virtualEntrypoint("unlisted-script", wxtConfig),
      devServerGlobals(wxtConfig),
      tsconfigPaths(wxtConfig),
      noopBackground(),
      globals(wxtConfig),
      excludeBrowserPolyfill(wxtConfig),
      defineImportMeta()
    );
    if (wxtConfig.analysis.enabled) {
      config.plugins.push(bundleAnalysis(wxtConfig));
    }
    return config;
  };
  const getLibModeConfig = (entrypoint) => {
    const entry = getRollupEntry(entrypoint);
    const plugins = [
      entrypointGroupGlobals(entrypoint)
    ];
    if (entrypoint.type === "content-script-style" || entrypoint.type === "unlisted-style") {
      plugins.push(cssEntrypoints(entrypoint, wxtConfig));
    }
    const libMode = {
      mode: wxtConfig.mode,
      plugins,
      build: {
        lib: {
          entry,
          formats: ["iife"],
          name: "_",
          fileName: entrypoint.name
        },
        rollupOptions: {
          output: {
            // There's only a single output for this build, so we use the desired bundle path for the
            // entry output (like "content-scripts/overlay.js")
            entryFileNames: getEntrypointBundlePath(
              entrypoint,
              wxtConfig.outDir,
              ".js"
            ),
            // Output content script CSS to `content-scripts/`, but all other scripts are written to
            // `assets/`.
            assetFileNames: ({ name }) => {
              if (entrypoint.type === "content-script" && name?.endsWith("css")) {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      },
      define: {
        // See https://github.com/aklinker1/vite-plugin-web-extension/issues/96
        "process.env.NODE_ENV": JSON.stringify(wxtConfig.mode)
      }
    };
    return libMode;
  };
  const getMultiPageConfig = (entrypoints) => {
    const htmlEntrypoints = new Set(
      entrypoints.filter(isHtmlEntrypoint).map((e) => e.name)
    );
    return {
      mode: wxtConfig.mode,
      plugins: [
        multipageMove(entrypoints, wxtConfig),
        entrypointGroupGlobals(entrypoints)
      ],
      build: {
        rollupOptions: {
          input: entrypoints.reduce((input, entry) => {
            input[entry.name] = getRollupEntry(entry);
            return input;
          }, {}),
          output: {
            // Include a hash to prevent conflicts
            chunkFileNames: "chunks/[name]-[hash].js",
            entryFileNames: ({ name }) => {
              if (htmlEntrypoints.has(name))
                return "chunks/[name]-[hash].js";
              return "[name].js";
            },
            // We can't control the "name", so we need a hash to prevent conflicts
            assetFileNames: "assets/[name]-[hash].[ext]"
          }
        }
      }
    };
  };
  const getCssConfig = (entrypoint) => {
    return {
      mode: wxtConfig.mode,
      plugins: [entrypointGroupGlobals(entrypoint)],
      build: {
        rollupOptions: {
          input: {
            [entrypoint.name]: entrypoint.inputPath
          },
          output: {
            assetFileNames: () => {
              if (entrypoint.type === "content-script-style") {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      }
    };
  };
  return {
    name: "Vite",
    version: vite.version,
    async build(group) {
      let entryConfig;
      if (Array.isArray(group))
        entryConfig = getMultiPageConfig(group);
      else if (group.inputPath.endsWith(".css"))
        entryConfig = getCssConfig(group);
      else
        entryConfig = getLibModeConfig(group);
      const buildConfig = vite.mergeConfig(await getBaseConfig(), entryConfig);
      const result = await vite.build(buildConfig);
      return {
        entrypoints: group,
        chunks: getBuildOutputChunks(result)
      };
    },
    async createServer(info) {
      const serverConfig = {
        server: {
          port: info.port,
          strictPort: true,
          host: info.hostname,
          origin: info.origin
        }
      };
      const baseConfig = await getBaseConfig();
      const viteServer = await vite.createServer(
        vite.mergeConfig(baseConfig, serverConfig)
      );
      const server = {
        async listen() {
          await viteServer.listen(info.port);
        },
        async close() {
          await viteServer.close();
        },
        transformHtml(...args) {
          return viteServer.transformIndexHtml(...args);
        },
        ws: {
          send(message, payload) {
            return viteServer.ws.send(message, payload);
          },
          on(message, cb) {
            viteServer.ws.on(message, cb);
          }
        },
        watcher: viteServer.watcher
      };
      return server;
    }
  };
}
function getBuildOutputChunks(result) {
  if ("on" in result)
    throw Error("wxt does not support vite watch mode.");
  if (Array.isArray(result))
    return result.flatMap(({ output }) => output);
  return result.output;
}
function getRollupEntry(entrypoint) {
  let virtualEntrypointType;
  switch (entrypoint.type) {
    case "background":
    case "unlisted-script":
      virtualEntrypointType = entrypoint.type;
      break;
    case "content-script":
      virtualEntrypointType = entrypoint.options.world === "MAIN" ? "content-script-main-world" : "content-script-isolated-world";
      break;
  }
  return virtualEntrypointType ? `virtual:wxt-${virtualEntrypointType}?${entrypoint.inputPath}` : entrypoint.inputPath;
}

// src/core/utils/building/resolve-config.ts
var import_defu = __toESM(require("defu"), 1);

// src/core/utils/package.ts
var import_node_path8 = require("path");
var import_fs_extra8 = __toESM(require("fs-extra"), 1);
async function getPackageJson() {
  const file = (0, import_node_path8.resolve)(wxt.config.root, "package.json");
  try {
    return await import_fs_extra8.default.readJson(file);
  } catch (err) {
    wxt.logger.debug(
      `Failed to read package.json at: ${file}. Returning undefined.`
    );
    return {};
  }
}
function isModuleInstalled(name) {
  return import(name).then(() => true).catch(() => false);
}

// src/core/utils/building/resolve-config.ts
async function resolveConfig(inlineConfig, command, server) {
  let userConfig = {};
  let userConfigMetadata;
  if (inlineConfig.configFile !== false) {
    const { config: loadedConfig, ...metadata } = await (0, import_c12.loadConfig)({
      configFile: inlineConfig.configFile,
      name: "wxt",
      cwd: inlineConfig.root ?? process.cwd(),
      rcFile: false,
      jitiOptions: {
        esmResolve: true
      }
    });
    userConfig = loadedConfig ?? {};
    userConfigMetadata = metadata;
  }
  const mergedConfig = mergeInlineConfig(inlineConfig, userConfig);
  const debug = mergedConfig.debug ?? false;
  const logger = mergedConfig.logger ?? import_consola.default;
  if (debug)
    logger.level = import_consola.LogLevels.debug;
  const browser = mergedConfig.browser ?? "chrome";
  const manifestVersion = mergedConfig.manifestVersion ?? (browser === "firefox" || browser === "safari" ? 2 : 3);
  const mode = mergedConfig.mode ?? (command === "build" ? "production" : "development");
  const env = { browser, command, manifestVersion, mode };
  const root = import_node_path9.default.resolve(
    inlineConfig.root ?? userConfig.root ?? process.cwd()
  );
  const wxtDir = import_node_path9.default.resolve(root, ".wxt");
  const srcDir = import_node_path9.default.resolve(root, mergedConfig.srcDir ?? root);
  const entrypointsDir = import_node_path9.default.resolve(
    srcDir,
    mergedConfig.entrypointsDir ?? "entrypoints"
  );
  const filterEntrypoints = !!mergedConfig.filterEntrypoints?.length ? new Set(mergedConfig.filterEntrypoints) : void 0;
  const publicDir = import_node_path9.default.resolve(srcDir, mergedConfig.publicDir ?? "public");
  const typesDir = import_node_path9.default.resolve(wxtDir, "types");
  const outBaseDir = import_node_path9.default.resolve(root, mergedConfig.outDir ?? ".output");
  const outDir = import_node_path9.default.resolve(outBaseDir, `${browser}-mv${manifestVersion}`);
  const reloadCommand = mergedConfig.dev?.reloadCommand ?? "Alt+R";
  const runnerConfig = await (0, import_c12.loadConfig)({
    name: "web-ext",
    cwd: root,
    globalRc: true,
    rcFile: ".webextrc",
    overrides: inlineConfig.runner,
    defaults: userConfig.runner
  });
  const alias = Object.fromEntries(
    Object.entries({
      ...mergedConfig.alias,
      "@": srcDir,
      "~": srcDir,
      "@@": root,
      "~~": root
    }).map(([key, value]) => [key, import_node_path9.default.resolve(root, value)])
  );
  const analysisOutputFile = import_node_path9.default.resolve(
    root,
    mergedConfig.analysis?.outputFile ?? "stats.html"
  );
  const analysisOutputDir = import_node_path9.default.dirname(analysisOutputFile);
  const analysisOutputName = import_node_path9.default.parse(analysisOutputFile).name;
  const finalConfig = {
    browser,
    command,
    debug,
    entrypointsDir,
    filterEntrypoints,
    env,
    fsCache: createFsCache(wxtDir),
    imports: await getUnimportOptions(wxtDir, logger, mergedConfig),
    logger,
    manifest: await resolveManifestConfig(env, mergedConfig.manifest),
    manifestVersion,
    mode,
    outBaseDir,
    outDir,
    publicDir,
    root,
    runnerConfig,
    srcDir,
    typesDir,
    wxtDir,
    zip: resolveInternalZipConfig(root, mergedConfig),
    transformManifest(manifest) {
      userConfig.transformManifest?.(manifest);
      inlineConfig.transformManifest?.(manifest);
    },
    analysis: {
      enabled: mergedConfig.analysis?.enabled ?? false,
      template: mergedConfig.analysis?.template ?? "treemap",
      outputFile: analysisOutputFile,
      outputDir: analysisOutputDir,
      outputName: analysisOutputName,
      keepArtifacts: mergedConfig.analysis?.keepArtifacts ?? false
    },
    userConfigMetadata: userConfigMetadata ?? {},
    alias,
    experimental: {
      includeBrowserPolyfill: mergedConfig.experimental?.includeBrowserPolyfill ?? true
    },
    server,
    dev: {
      reloadCommand
    },
    hooks: mergedConfig.hooks ?? {}
  };
  const builder = await createViteBuilder(
    inlineConfig,
    userConfig,
    finalConfig
  );
  return {
    ...finalConfig,
    builder
  };
}
async function resolveManifestConfig(env, manifest) {
  return await (typeof manifest === "function" ? manifest(env) : manifest ?? {});
}
function mergeInlineConfig(inlineConfig, userConfig) {
  let imports;
  if (inlineConfig.imports === false || userConfig.imports === false) {
    imports = false;
  } else if (userConfig.imports == null && inlineConfig.imports == null) {
    imports = void 0;
  } else {
    imports = (0, import_defu.default)(inlineConfig.imports ?? {}, userConfig.imports ?? {});
  }
  const manifest = async (env) => {
    const user = await resolveManifestConfig(env, userConfig.manifest);
    const inline = await resolveManifestConfig(env, inlineConfig.manifest);
    return (0, import_defu.default)(inline, user);
  };
  const runner = (0, import_defu.default)(
    inlineConfig.runner ?? {},
    userConfig.runner ?? {}
  );
  const zip2 = (0, import_defu.default)(
    inlineConfig.zip ?? {},
    userConfig.zip ?? {}
  );
  const hooks = (0, import_defu.default)(
    inlineConfig.hooks ?? {},
    userConfig.hooks ?? {}
  );
  return {
    root: inlineConfig.root ?? userConfig.root,
    browser: inlineConfig.browser ?? userConfig.browser,
    manifestVersion: inlineConfig.manifestVersion ?? userConfig.manifestVersion,
    configFile: inlineConfig.configFile,
    debug: inlineConfig.debug ?? userConfig.debug,
    entrypointsDir: inlineConfig.entrypointsDir ?? userConfig.entrypointsDir,
    filterEntrypoints: inlineConfig.filterEntrypoints ?? userConfig.filterEntrypoints,
    imports,
    logger: inlineConfig.logger ?? userConfig.logger,
    manifest,
    mode: inlineConfig.mode ?? userConfig.mode,
    publicDir: inlineConfig.publicDir ?? userConfig.publicDir,
    runner,
    srcDir: inlineConfig.srcDir ?? userConfig.srcDir,
    outDir: inlineConfig.outDir ?? userConfig.outDir,
    zip: zip2,
    analysis: {
      ...userConfig.analysis,
      ...inlineConfig.analysis
    },
    alias: {
      ...userConfig.alias,
      ...inlineConfig.alias
    },
    experimental: {
      ...userConfig.experimental,
      ...inlineConfig.experimental
    },
    vite: void 0,
    transformManifest: void 0,
    dev: {
      ...userConfig.dev,
      ...inlineConfig.dev
    },
    hooks
  };
}
function resolveInternalZipConfig(root, mergedConfig) {
  return {
    name: void 0,
    sourcesTemplate: "{{name}}-{{version}}-sources.zip",
    artifactTemplate: "{{name}}-{{version}}-{{browser}}.zip",
    sourcesRoot: root,
    includeSources: [],
    ...mergedConfig.zip,
    excludeSources: [
      "**/node_modules",
      // WXT files
      "**/web-ext.config.ts",
      // Hidden files
      "**/.*",
      // Tests
      "**/__tests__/**",
      "**/*.+(test|spec).?(c|m)+(j|t)s?(x)",
      // From user
      ...mergedConfig.zip?.excludeSources ?? []
    ]
  };
}
async function getUnimportOptions(wxtDir, logger, config) {
  if (config.imports === false)
    return false;
  const enabledConfig = config.imports?.eslintrc?.enabled;
  let enabled;
  switch (enabledConfig) {
    case void 0:
    case "auto":
      enabled = await isModuleInstalled("eslint");
      break;
    default:
      enabled = enabledConfig;
  }
  const defaultOptions = {
    debugLog: logger.debug,
    imports: [
      { name: "defineConfig", from: "wxt" },
      { name: "fakeBrowser", from: "wxt/testing" }
    ],
    presets: [
      { package: "wxt/client" },
      { package: "wxt/browser" },
      { package: "wxt/sandbox" },
      { package: "wxt/storage" }
    ],
    warn: logger.warn,
    dirs: ["components", "composables", "hooks", "utils"],
    eslintrc: {
      enabled,
      filePath: import_node_path9.default.resolve(wxtDir, "eslintrc-auto-import.json"),
      globalsPropValue: true
    }
  };
  return (0, import_defu.default)(
    config.imports ?? {},
    defaultOptions
  );
}

// src/core/utils/building/group-entrypoints.ts
function groupEntrypoints(entrypoints) {
  const groupIndexMap = {};
  const groups = [];
  for (const entry of entrypoints) {
    let group = ENTRY_TYPE_TO_GROUP_MAP[entry.type];
    if (entry.type === "background" && entry.options.type === "module") {
      group = "esm";
    }
    if (group === "individual") {
      groups.push(entry);
    } else {
      let groupIndex = groupIndexMap[group];
      if (groupIndex == null) {
        groupIndex = groups.push([]) - 1;
        groupIndexMap[group] = groupIndex;
      }
      groups[groupIndex].push(entry);
    }
  }
  return groups;
}
var ENTRY_TYPE_TO_GROUP_MAP = {
  sandbox: "sandboxed-esm",
  popup: "esm",
  newtab: "esm",
  history: "esm",
  options: "esm",
  devtools: "esm",
  bookmarks: "esm",
  sidepanel: "esm",
  "unlisted-page": "esm",
  background: "individual",
  "content-script": "individual",
  "unlisted-script": "individual",
  "unlisted-style": "individual",
  "content-script-style": "individual"
};

// src/core/utils/building/import-entrypoint.ts
var import_jiti = __toESM(require("jiti"), 1);
var import_unimport3 = require("unimport");
var import_fs_extra9 = __toESM(require("fs-extra"), 1);
var import_node_path10 = require("path");

// src/core/utils/strings.ts
function kebabCaseAlphanumeric(str) {
  return str.toLowerCase().replace(/[^a-z0-9-\s]/g, "").replace(/\s+/g, "-");
}
function removeImportStatements(text) {
  return text.replace(
    /(import\s?[{\w][\s\S]*?from\s?["'][\s\S]*?["'];?|import\s?["'][\s\S]*?["'];?)/gm,
    ""
  );
}
function removeProjectImportStatements(text) {
  const noImports = removeImportStatements(text);
  return `import { defineUnlistedScript, defineContentScript, defineBackground } from 'wxt/sandbox';

${noImports}`;
}

// src/core/utils/building/import-entrypoint.ts
var import_esbuild = require("esbuild");
var import_node_url = require("url");
var import_meta = {};
async function importEntrypointFile(path11) {
  wxt.logger.debug("Loading file metadata:", path11);
  const normalPath = normalizePath(path11);
  const unimport2 = (0, import_unimport3.createUnimport)({
    ...wxt.config.imports,
    // Only allow specific imports, not all from the project
    dirs: []
  });
  await unimport2.init();
  const text = await import_fs_extra9.default.readFile(path11, "utf-8");
  const textNoImports = removeProjectImportStatements(text);
  const { code } = await unimport2.injectImports(textNoImports);
  wxt.logger.debug(
    ["Text:", text, "No imports:", textNoImports, "Code:", code].join("\n")
  );
  const jiti = (0, import_jiti.default)(
    typeof __filename !== "undefined" ? __filename : (0, import_node_url.fileURLToPath)(import_meta.url),
    {
      cache: false,
      debug: wxt.config.debug,
      esmResolve: true,
      alias: {
        "webextension-polyfill": (0, import_node_path10.resolve)(
          wxt.config.root,
          "node_modules/wxt/dist/virtual/mock-browser.js"
        )
      },
      // Continue using node to load TS files even if `bun run --bun` is detected. Jiti does not
      // respect the custom transform function when using it's native bun option.
      experimentalBun: false,
      // List of extensions to transform with esbuild
      extensions: [
        ".ts",
        ".cts",
        ".mts",
        ".tsx",
        ".js",
        ".cjs",
        ".mjs",
        ".jsx"
      ],
      transform(opts) {
        const isEntrypoint = opts.filename === normalPath;
        return (0, import_esbuild.transformSync)(
          // Use modified source code for entrypoints
          isEntrypoint ? code : opts.source,
          getEsbuildOptions(opts)
        );
      }
    }
  );
  try {
    const res = await jiti(path11);
    return res.default;
  } catch (err) {
    const filePath = (0, import_node_path10.relative)(wxt.config.root, path11);
    if (err instanceof ReferenceError) {
      const variableName = err.message.replace(" is not defined", "");
      throw Error(
        `${filePath}: Cannot use imported variable "${variableName}" outside the main function. See https://wxt.dev/guide/entrypoints.html#side-effects`,
        { cause: err }
      );
    } else {
      wxt.logger.error(err);
      throw Error(`Failed to load entrypoint: ${filePath}`, { cause: err });
    }
  }
}
function getEsbuildOptions(opts) {
  const isJsx = opts.filename?.endsWith("x");
  return {
    format: "cjs",
    loader: isJsx ? "tsx" : "ts",
    ...isJsx ? {
      // `h` and `Fragment` are undefined, but that's OK because JSX is never evaluated while
      // grabbing the entrypoint's options.
      jsxFactory: "h",
      jsxFragment: "Fragment"
    } : void 0
  };
}

// src/core/utils/building/internal-build.ts
var import_picocolors5 = __toESM(require("picocolors"), 1);
var import_fs_extra12 = __toESM(require("fs-extra"), 1);

// src/core/utils/log/printBuildSummary.ts
var import_path7 = require("path");

// src/core/utils/log/printFileList.ts
var import_node_path11 = __toESM(require("path"), 1);
var import_picocolors3 = __toESM(require("picocolors"), 1);
var import_fs_extra10 = __toESM(require("fs-extra"), 1);
var import_filesize = require("filesize");

// src/core/utils/log/printTable.ts
function printTable(log, header, rows, gap = 2) {
  if (rows.length === 0)
    return;
  const columnWidths = rows.reduce(
    (widths, row) => {
      for (let i = 0; i < Math.max(widths.length, row.length); i++) {
        widths[i] = Math.max(row[i]?.length ?? 0, widths[i] ?? 0);
      }
      return widths;
    },
    rows[0].map((column) => column.length)
  );
  let str = "";
  rows.forEach((row, i) => {
    row.forEach((col, j) => {
      str += col.padEnd(columnWidths[j], " ");
      if (j !== row.length - 1)
        str += "".padEnd(gap, " ");
    });
    if (i !== rows.length - 1)
      str += "\n";
  });
  log(`${header}
${str}`);
}

// src/core/utils/log/printFileList.ts
async function printFileList(log, header, baseDir, files) {
  let totalSize = 0;
  const fileRows = await Promise.all(
    files.map(async (file, i) => {
      const parts = [
        import_node_path11.default.relative(process.cwd(), baseDir) + import_node_path11.default.sep,
        import_node_path11.default.relative(baseDir, file)
      ];
      const prefix = i === files.length - 1 ? "  \u2514\u2500" : "  \u251C\u2500";
      const color = getChunkColor(file);
      const stats = await import_fs_extra10.default.lstat(file);
      totalSize += stats.size;
      const size = String((0, import_filesize.filesize)(stats.size));
      return [
        `${import_picocolors3.default.gray(prefix)} ${import_picocolors3.default.dim(parts[0])}${color(parts[1])}`,
        import_picocolors3.default.dim(size)
      ];
    })
  );
  fileRows.push([`${import_picocolors3.default.cyan("\u03A3 Total size:")} ${String((0, import_filesize.filesize)(totalSize))}`]);
  printTable(log, header, fileRows);
}
var DEFAULT_COLOR = import_picocolors3.default.blue;
var CHUNK_COLORS = {
  ".js.map": import_picocolors3.default.gray,
  ".cjs.map": import_picocolors3.default.gray,
  ".mjs.map": import_picocolors3.default.gray,
  ".html": import_picocolors3.default.green,
  ".css": import_picocolors3.default.magenta,
  ".js": import_picocolors3.default.cyan,
  ".cjs": import_picocolors3.default.cyan,
  ".mjs": import_picocolors3.default.cyan,
  ".zip": import_picocolors3.default.yellow
};
function getChunkColor(filename) {
  return Object.entries(CHUNK_COLORS).find(([key]) => filename.endsWith(key))?.[1] ?? DEFAULT_COLOR;
}

// src/core/utils/log/printBuildSummary.ts
async function printBuildSummary(log, header, output) {
  const chunks = [
    ...output.steps.flatMap((step) => step.chunks),
    ...output.publicAssets
  ].sort((l, r) => {
    const lWeight = getChunkSortWeight(l.fileName);
    const rWeight = getChunkSortWeight(r.fileName);
    const diff = lWeight - rWeight;
    if (diff !== 0)
      return diff;
    return l.fileName.localeCompare(r.fileName);
  });
  const files = chunks.map(
    (chunk) => (0, import_path7.resolve)(wxt.config.outDir, chunk.fileName)
  );
  await printFileList(log, header, wxt.config.outDir, files);
}
var DEFAULT_SORT_WEIGHT = 100;
var CHUNK_SORT_WEIGHTS = {
  "manifest.json": 0,
  ".html": 1,
  ".js.map": 2,
  ".js": 2,
  ".css": 3
};
function getChunkSortWeight(filename) {
  return Object.entries(CHUNK_SORT_WEIGHTS).find(
    ([key]) => filename.endsWith(key)
  )?.[1] ?? DEFAULT_SORT_WEIGHT;
}

// src/core/utils/log/printHeader.ts
var import_picocolors4 = __toESM(require("picocolors"), 1);

// package.json
var version = "0.16.11";

// src/core/utils/log/printHeader.ts
var import_consola2 = require("consola");

// src/core/utils/building/internal-build.ts
var import_fast_glob3 = __toESM(require("fast-glob"), 1);

// src/core/utils/manifest.ts
var import_fs_extra11 = __toESM(require("fs-extra"), 1);
var import_path8 = require("path");

// src/core/utils/content-security-policy.ts
var ContentSecurityPolicy = class _ContentSecurityPolicy {
  static DIRECTIVE_ORDER = {
    "default-src": 0,
    "script-src": 1,
    "object-src": 2
  };
  data;
  constructor(csp) {
    if (csp) {
      const sections = csp.split(";").map((section) => section.trim());
      this.data = sections.reduce((data, section) => {
        const [key, ...values] = section.split(" ").map((item) => item.trim());
        if (key)
          data[key] = values;
        return data;
      }, {});
    } else {
      this.data = {};
    }
  }
  /**
   * Ensure a set of values are listed under a directive.
   */
  add(directive, ...newValues) {
    const values = this.data[directive] ?? [];
    newValues.forEach((newValue) => {
      if (!values.includes(newValue))
        values.push(newValue);
    });
    this.data[directive] = values;
    return this;
  }
  toString() {
    const directives = Object.entries(this.data).sort(([l], [r]) => {
      const lo = _ContentSecurityPolicy.DIRECTIVE_ORDER[l] ?? 2;
      const ro = _ContentSecurityPolicy.DIRECTIVE_ORDER[r] ?? 2;
      return lo - ro;
    });
    return directives.map((entry) => entry.flat().join(" ")).join("; ") + ";";
  }
};

// src/core/utils/content-scripts.ts
function hashContentScriptOptions(options) {
  const simplifiedOptions = mapWxtOptionsToContentScript(
    options,
    void 0,
    void 0
  );
  Object.keys(simplifiedOptions).forEach((key) => {
    if (simplifiedOptions[key] == null)
      delete simplifiedOptions[key];
  });
  const withDefaults = {
    exclude_globs: [],
    exclude_matches: [],
    include_globs: [],
    match_about_blank: false,
    run_at: "document_idle",
    all_frames: false,
    // @ts-expect-error - not in type
    match_origin_as_fallback: false,
    world: "ISOLATED",
    ...simplifiedOptions
  };
  return JSON.stringify(
    Object.entries(withDefaults).map(([key, value]) => {
      if (Array.isArray(value))
        return [key, value.sort()];
      else
        return [key, value];
    }).sort((l, r) => l[0].localeCompare(r[0]))
  );
}
function mapWxtOptionsToContentScript(options, js, css) {
  return {
    matches: options.matches,
    all_frames: options.allFrames,
    match_about_blank: options.matchAboutBlank,
    exclude_globs: options.excludeGlobs,
    exclude_matches: options.excludeMatches,
    include_globs: options.includeGlobs,
    run_at: options.runAt,
    css,
    js,
    // @ts-expect-error: untyped chrome options
    match_origin_as_fallback: options.matchOriginAsFallback,
    world: options.world
  };
}
function mapWxtOptionsToRegisteredContentScript(options, js, css) {
  return {
    allFrames: options.allFrames,
    excludeMatches: options.excludeMatches,
    matches: options.matches,
    runAt: options.runAt,
    js,
    css,
    // @ts-expect-error: Chrome accepts this, not typed in webextension-polyfill (https://developer.chrome.com/docs/extensions/reference/scripting/#type-RegisteredContentScript)
    world: options.world
  };
}

// src/core/utils/manifest.ts
var import_defu2 = __toESM(require("defu"), 1);
async function writeManifest(manifest, output) {
  const str = wxt.config.mode === "production" ? JSON.stringify(manifest) : JSON.stringify(manifest, null, 2);
  await import_fs_extra11.default.ensureDir(wxt.config.outDir);
  await writeFileIfDifferent((0, import_path8.resolve)(wxt.config.outDir, "manifest.json"), str);
  output.publicAssets.unshift({
    type: "asset",
    fileName: "manifest.json"
  });
}
async function generateManifest(entrypoints, buildOutput) {
  const warnings = [];
  const pkg = await getPackageJson();
  let versionName = wxt.config.manifest.version_name ?? wxt.config.manifest.version ?? pkg?.version;
  if (versionName == null) {
    versionName = "0.0.0";
    wxt.logger.warn(
      'Extension version not found, defaulting to "0.0.0". Add a version to your `package.json` or `wxt.config.ts` file. For more details, see: https://wxt.dev/guide/manifest.html#version-and-version-name'
    );
  }
  const version2 = wxt.config.manifest.version ?? simplifyVersion(versionName);
  const baseManifest = {
    manifest_version: wxt.config.manifestVersion,
    name: pkg?.name,
    description: pkg?.description,
    version: version2,
    short_name: pkg?.shortName,
    icons: discoverIcons(buildOutput)
  };
  const userManifest = wxt.config.manifest;
  let manifest = (0, import_defu2.default)(
    userManifest,
    baseManifest
  );
  if (wxt.config.command === "serve" && wxt.config.dev.reloadCommand) {
    if (manifest.commands && Object.keys(manifest.commands).length >= 4) {
      warnings.push([
        "Extension already has 4 registered commands, WXT's reload command is disabled"
      ]);
    } else {
      manifest.commands ??= {};
      manifest.commands["wxt:reload-extension"] = {
        description: "Reload the extension during development",
        suggested_key: {
          default: wxt.config.dev.reloadCommand
        }
      };
    }
  }
  manifest.version = version2;
  manifest.version_name = // Firefox doesn't support version_name
  wxt.config.browser === "firefox" || versionName === version2 ? void 0 : versionName;
  addEntrypoints(manifest, entrypoints, buildOutput);
  if (wxt.config.command === "serve")
    addDevModeCsp(manifest);
  if (wxt.config.command === "serve")
    addDevModePermissions(manifest);
  wxt.config.transformManifest(manifest);
  await wxt.hooks.callHook("build:manifestGenerated", wxt, manifest);
  if (wxt.config.manifestVersion === 2)
    convertWebAccessibleResourcesToMv2(manifest);
  if (wxt.config.manifestVersion === 3) {
    validateMv3WebAccessbileResources(manifest);
  }
  if (manifest.name == null)
    throw Error(
      "Manifest 'name' is missing. Either:\n1. Set the name in your <rootDir>/package.json\n2. Set a name via the manifest option in your wxt.config.ts"
    );
  if (manifest.version == null) {
    throw Error(
      "Manifest 'version' is missing. Either:\n1. Add a version in your <rootDir>/package.json\n2. Pass the version via the manifest option in your wxt.config.ts"
    );
  }
  return {
    manifest,
    warnings
  };
}
function simplifyVersion(versionName) {
  const version2 = /^((0|[1-9][0-9]{0,8})([.](0|[1-9][0-9]{0,8})){0,3}).*$/.exec(
    versionName
  )?.[1];
  if (version2 == null)
    throw Error(
      `Cannot simplify package.json version "${versionName}" to a valid extension version, "X.Y.Z"`
    );
  return version2;
}
function addEntrypoints(manifest, entrypoints, buildOutput) {
  const entriesByType = entrypoints.reduce((map, entrypoint) => {
    map[entrypoint.type] ??= [];
    map[entrypoint.type]?.push(entrypoint);
    return map;
  }, {});
  const background = entriesByType["background"]?.[0];
  const bookmarks = entriesByType["bookmarks"]?.[0];
  const contentScripts = entriesByType["content-script"];
  const devtools = entriesByType["devtools"]?.[0];
  const history = entriesByType["history"]?.[0];
  const newtab = entriesByType["newtab"]?.[0];
  const options = entriesByType["options"]?.[0];
  const popup = entriesByType["popup"]?.[0];
  const sandboxes = entriesByType["sandbox"];
  const sidepanels = entriesByType["sidepanel"];
  if (background) {
    const script = getEntrypointBundlePath(
      background,
      wxt.config.outDir,
      ".js"
    );
    if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        scripts: [script]
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        service_worker: script
      };
    } else {
      manifest.background = {
        persistent: background.options.persistent,
        scripts: [script]
      };
    }
  }
  if (bookmarks) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.bookmarks was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.bookmarks = getEntrypointBundlePath(
        bookmarks,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (history) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.history was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.history = getEntrypointBundlePath(
        history,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (newtab) {
    manifest.chrome_url_overrides ??= {};
    manifest.chrome_url_overrides.newtab = getEntrypointBundlePath(
      newtab,
      wxt.config.outDir,
      ".html"
    );
  }
  if (popup) {
    const default_popup = getEntrypointBundlePath(
      popup,
      wxt.config.outDir,
      ".html"
    );
    const options2 = {};
    if (popup.options.defaultIcon)
      options2.default_icon = popup.options.defaultIcon;
    if (popup.options.defaultTitle)
      options2.default_title = popup.options.defaultTitle;
    if (popup.options.browserStyle)
      options2.browser_style = popup.options.browserStyle;
    if (manifest.manifest_version === 3) {
      manifest.action = {
        ...manifest.action ?? {},
        ...options2,
        default_popup
      };
    } else {
      const key = popup.options.mv2Key ?? "browser_action";
      manifest[key] = {
        ...manifest[key] ?? {},
        ...options2,
        default_popup
      };
    }
  }
  if (devtools) {
    manifest.devtools_page = getEntrypointBundlePath(
      devtools,
      wxt.config.outDir,
      ".html"
    );
  }
  if (options) {
    const page = getEntrypointBundlePath(options, wxt.config.outDir, ".html");
    manifest.options_ui = {
      open_in_tab: options.options.openInTab,
      browser_style: wxt.config.browser === "firefox" ? options.options.browserStyle : void 0,
      chrome_style: wxt.config.browser !== "firefox" ? options.options.chromeStyle : void 0,
      page
    };
  }
  if (sandboxes?.length) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Sandboxed pages not supported by Firefox. sandbox.pages was not added to the manifest"
      );
    } else {
      manifest.sandbox = {
        pages: sandboxes.map(
          (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".html")
        )
      };
    }
  }
  if (sidepanels?.length) {
    const defaultSidepanel = sidepanels.find((entry) => entry.name === "sidepanel") ?? sidepanels[0];
    const page = getEntrypointBundlePath(
      defaultSidepanel,
      wxt.config.outDir,
      ".html"
    );
    if (wxt.config.browser === "firefox") {
      manifest.sidebar_action = {
        default_panel: page,
        browser_style: defaultSidepanel.options.browserStyle,
        default_icon: defaultSidepanel.options.defaultIcon,
        default_title: defaultSidepanel.options.defaultTitle,
        open_at_install: defaultSidepanel.options.openAtInstall
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.side_panel = {
        default_path: page
      };
    } else {
      wxt.logger.warn(
        "Side panel not supported by Chromium using MV2. side_panel.default_path was not added to the manifest"
      );
    }
  }
  if (contentScripts?.length) {
    const cssMap = getContentScriptsCssMap(buildOutput, contentScripts);
    if (wxt.config.command === "serve" && wxt.config.manifestVersion === 3) {
      contentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    } else {
      const hashToEntrypointsMap = contentScripts.filter((cs) => cs.options.registration !== "runtime").reduce((map, script) => {
        const hash = hashContentScriptOptions(script.options);
        if (map.has(hash))
          map.get(hash)?.push(script);
        else
          map.set(hash, [script]);
        return map;
      }, /* @__PURE__ */ new Map());
      const manifestContentScripts = Array.from(
        hashToEntrypointsMap.values()
      ).map(
        (scripts) => mapWxtOptionsToContentScript(
          scripts[0].options,
          scripts.map(
            (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".js")
          ),
          getContentScriptCssFiles(scripts, cssMap)
        )
      );
      if (manifestContentScripts.length >= 0) {
        manifest.content_scripts ??= [];
        manifest.content_scripts.push(...manifestContentScripts);
      }
      const runtimeContentScripts = contentScripts.filter(
        (cs) => cs.options.registration === "runtime"
      );
      if (runtimeContentScripts.length > 0 && wxt.config.manifestVersion === 2) {
        throw Error(
          'Cannot use `registration: "runtime"` with MV2 content scripts, it is a MV3-only feature.'
        );
      }
      runtimeContentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    }
    const contentScriptCssResources = getContentScriptCssWebAccessibleResources(
      contentScripts,
      cssMap
    );
    if (contentScriptCssResources.length > 0) {
      manifest.web_accessible_resources ??= [];
      manifest.web_accessible_resources.push(...contentScriptCssResources);
    }
  }
}
function discoverIcons(buildOutput) {
  const icons = [];
  const iconRegex = [
    /^icon-([0-9]+)\.png$/,
    // icon-16.png
    /^icon-([0-9]+)x[0-9]+\.png$/,
    // icon-16x16.png
    /^icon@([0-9]+)w\.png$/,
    // icon@16w.png
    /^icon@([0-9]+)h\.png$/,
    // icon@16h.png
    /^icon@([0-9]+)\.png$/,
    // icon@16.png
    /^icons?[\/\\]([0-9]+)\.png$/,
    // icon/16.png | icons/16.png
    /^icons?[\/\\]([0-9]+)x[0-9]+\.png$/
    // icon/16x16.png | icons/16x16.png
  ];
  buildOutput.publicAssets.forEach((asset) => {
    let size;
    for (const regex of iconRegex) {
      const match = asset.fileName.match(regex);
      if (match?.[1] != null) {
        size = match[1];
        break;
      }
    }
    if (size == null)
      return;
    icons.push([size, normalizePath(asset.fileName)]);
  });
  return icons.length > 0 ? Object.fromEntries(icons) : void 0;
}
function addDevModeCsp(manifest) {
  const permission = `http://${wxt.config.server?.hostname ?? ""}/*`;
  const allowedCsp = wxt.config.server?.origin ?? "http://localhost:*";
  if (manifest.manifest_version === 3) {
    addHostPermission(manifest, permission);
  } else {
    addPermission(manifest, permission);
  }
  const csp = new ContentSecurityPolicy(
    manifest.manifest_version === 3 ? (
      // @ts-expect-error: extension_pages is not typed
      manifest.content_security_policy?.extension_pages ?? "script-src 'self' 'wasm-unsafe-eval'; object-src 'self';"
    ) : manifest.content_security_policy ?? "script-src 'self'; object-src 'self';"
    // default CSP for MV2
  );
  if (wxt.config.server)
    csp.add("script-src", allowedCsp);
  if (manifest.manifest_version === 3) {
    manifest.content_security_policy ??= {};
    manifest.content_security_policy.extension_pages = csp.toString();
  } else {
    manifest.content_security_policy = csp.toString();
  }
}
function addDevModePermissions(manifest) {
  addPermission(manifest, "tabs");
  if (wxt.config.manifestVersion === 3)
    addPermission(manifest, "scripting");
}
function getContentScriptCssFiles(contentScripts, contentScriptCssMap) {
  const css = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode === "manual" || script.options.cssInjectionMode === "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    if (cssFile)
      css.push(cssFile);
  });
  if (css.length > 0)
    return css;
  return void 0;
}
function getContentScriptCssWebAccessibleResources(contentScripts, contentScriptCssMap) {
  const resources = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode !== "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    resources.push({
      resources: [cssFile],
      matches: script.options.matches.map(
        (matchPattern) => stripPathFromMatchPattern(matchPattern)
      )
    });
  });
  return resources;
}
function getContentScriptsCssMap(buildOutput, scripts) {
  const map = {};
  const allChunks = buildOutput.steps.flatMap((step) => step.chunks);
  scripts.forEach((script) => {
    const relatedCss = allChunks.find(
      (chunk) => chunk.fileName === `content-scripts/${script.name}.css`
    );
    if (relatedCss != null)
      map[script.name] = relatedCss.fileName;
  });
  return map;
}
function addPermission(manifest, permission) {
  manifest.permissions ??= [];
  if (manifest.permissions.includes(permission))
    return;
  manifest.permissions.push(permission);
}
function addHostPermission(manifest, hostPermission) {
  manifest.host_permissions ??= [];
  if (manifest.host_permissions.includes(hostPermission))
    return;
  manifest.host_permissions.push(hostPermission);
}
function stripPathFromMatchPattern(pattern) {
  const protocolSepIndex = pattern.indexOf("://");
  if (protocolSepIndex === -1)
    return pattern;
  const startOfPath = pattern.indexOf("/", protocolSepIndex + 3);
  return pattern.substring(0, startOfPath) + "/*";
}
function convertWebAccessibleResourcesToMv2(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  manifest.web_accessible_resources = Array.from(
    new Set(
      manifest.web_accessible_resources.flatMap((item) => {
        if (typeof item === "string")
          return item;
        return item.resources;
      })
    )
  );
}
function validateMv3WebAccessbileResources(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  const stringResources = manifest.web_accessible_resources.filter(
    (item) => typeof item === "string"
  );
  if (stringResources.length > 0) {
    throw Error(
      `Non-MV3 web_accessible_resources detected: ${JSON.stringify(
        stringResources
      )}. When manually defining web_accessible_resources, define them as MV3 objects ({ matches: [...], resources: [...] }), and WXT will automatically convert them to MV2 when necessary.`
    );
  }
}

// src/core/utils/building/rebuild.ts
async function rebuild(allEntrypoints, entrypointGroups, existingOutput = {
  steps: [],
  publicAssets: []
}) {
  const { default: ora } = await import("ora");
  const spinner = ora(`Preparing...`).start();
  await generateTypesDir(allEntrypoints).catch((err) => {
    wxt.logger.warn("Failed to update .wxt directory:", err);
    if (wxt.config.command === "build")
      throw err;
  });
  const newOutput = await buildEntrypoints(entrypointGroups, spinner);
  const mergedOutput = {
    steps: [...existingOutput.steps, ...newOutput.steps],
    publicAssets: [...existingOutput.publicAssets, ...newOutput.publicAssets]
  };
  const { manifest: newManifest, warnings: manifestWarnings } = await generateManifest(allEntrypoints, mergedOutput);
  const finalOutput = {
    manifest: newManifest,
    ...newOutput
  };
  await writeManifest(newManifest, finalOutput);
  spinner.clear().stop();
  return {
    output: {
      manifest: newManifest,
      steps: [...existingOutput.steps, ...finalOutput.steps],
      publicAssets: [
        ...existingOutput.publicAssets,
        ...finalOutput.publicAssets
      ]
    },
    manifest: newManifest,
    warnings: manifestWarnings
  };
}

// src/core/utils/building/internal-build.ts
var import_node_path15 = require("path");

// src/core/utils/validation.ts
function validateEntrypoints(entrypoints) {
  const errors = entrypoints.flatMap((entrypoint) => {
    switch (entrypoint.type) {
      case "content-script":
        return validateContentScriptEntrypoint(entrypoint);
      default:
        return validateBaseEntrypoint(entrypoint);
    }
  });
  let errorCount = 0;
  let warningCount = 0;
  for (const err of errors) {
    if (err.type === "warning")
      warningCount++;
    else
      errorCount++;
  }
  return {
    errors,
    errorCount,
    warningCount
  };
}
function validateContentScriptEntrypoint(definition) {
  const errors = validateBaseEntrypoint(definition);
  if (definition.options.matches == null) {
    errors.push({
      type: "error",
      message: "`matches` is required",
      value: definition.options.matches,
      entrypoint: definition
    });
  }
  return errors;
}
function validateBaseEntrypoint(definition) {
  const errors = [];
  if (definition.options.exclude != null && !Array.isArray(definition.options.exclude)) {
    errors.push({
      type: "error",
      message: "`exclude` must be an array of browser names",
      value: definition.options.exclude,
      entrypoint: definition
    });
  }
  if (definition.options.include != null && !Array.isArray(definition.options.include)) {
    errors.push({
      type: "error",
      message: "`include` must be an array of browser names",
      value: definition.options.include,
      entrypoint: definition
    });
  }
  return errors;
}
var ValidationError = class extends Error {
};

// src/core/utils/building/internal-build.ts
var import_consola3 = __toESM(require("consola"), 1);

// src/core/utils/exec.ts
var import_manage_path = __toESM(require("manage-path"), 1);
var import_node_path14 = require("path");
var managedPath = (0, import_manage_path.default)(process.env);
var exec = async (file, args, options) => {
  managedPath.restore();
  managedPath.push(
    (0, import_node_path14.resolve)(wxt.config.root, "node_modules/wxt/node_modules/.bin")
  );
  const { execa: execa2 } = await Promise.resolve().then(() => (init_execa(), execa_exports));
  return await execa2(file, args, options);
};

// src/core/utils/building/internal-build.ts
async function internalBuild() {
  await wxt.hooks.callHook("build:before", wxt);
  const verb = wxt.config.command === "serve" ? "Pre-rendering" : "Building";
  const target = `${wxt.config.browser}-mv${wxt.config.manifestVersion}`;
  wxt.logger.info(
    `${verb} ${import_picocolors5.default.cyan(target)} for ${import_picocolors5.default.cyan(wxt.config.mode)} with ${import_picocolors5.default.green(
      `${wxt.config.builder.name} ${wxt.config.builder.version}`
    )}`
  );
  const startTime = Date.now();
  await import_fs_extra12.default.rm(wxt.config.outDir, { recursive: true, force: true });
  await import_fs_extra12.default.ensureDir(wxt.config.outDir);
  const entrypoints = await findEntrypoints();
  wxt.logger.debug("Detected entrypoints:", entrypoints);
  const validationResults = validateEntrypoints(entrypoints);
  if (validationResults.errorCount + validationResults.warningCount > 0) {
    printValidationResults(validationResults);
  }
  if (validationResults.errorCount > 0) {
    throw new ValidationError(`Entrypoint validation failed`, {
      cause: validationResults
    });
  }
  const groups = groupEntrypoints(entrypoints);
  await wxt.hooks.callHook("entrypoints:grouped", wxt, groups);
  const { output, warnings } = await rebuild(entrypoints, groups, void 0);
  await wxt.hooks.callHook("build:done", wxt, output);
  await printBuildSummary(
    wxt.logger.success,
    `Built extension in ${formatDuration(Date.now() - startTime)}`,
    output
  );
  for (const warning of warnings) {
    wxt.logger.warn(...warning);
  }
  if (wxt.config.analysis.enabled) {
    await combineAnalysisStats();
    const statsPath = (0, import_node_path15.relative)(wxt.config.root, wxt.config.analysis.outputFile);
    wxt.logger.info(
      `Analysis complete:
  ${import_picocolors5.default.gray("\u2514\u2500")} ${import_picocolors5.default.yellow(statsPath)}`
    );
  }
  return output;
}
async function combineAnalysisStats() {
  const unixFiles = await (0, import_fast_glob3.default)(`${wxt.config.analysis.outputName}-*.json`, {
    cwd: wxt.config.analysis.outputDir,
    absolute: true
  });
  const absolutePaths = unixFiles.map(unnormalizePath);
  await exec(
    "rollup-plugin-visualizer",
    [
      ...absolutePaths,
      "--template",
      wxt.config.analysis.template,
      "--filename",
      wxt.config.analysis.outputFile
    ],
    { cwd: wxt.config.root, stdio: "inherit" }
  );
  if (!wxt.config.analysis.keepArtifacts) {
    await Promise.all(absolutePaths.map((statsFile) => import_fs_extra12.default.remove(statsFile)));
  }
}
function printValidationResults({
  errorCount,
  errors,
  warningCount
}) {
  (errorCount > 0 ? wxt.logger.error : wxt.logger.warn)(
    `Entrypoint validation failed: ${errorCount} error${errorCount === 1 ? "" : "s"}, ${warningCount} warning${warningCount === 1 ? "" : "s"}`
  );
  const cwd = process.cwd();
  const entrypointErrors = errors.reduce((map, error) => {
    const entryErrors = map.get(error.entrypoint) ?? [];
    entryErrors.push(error);
    map.set(error.entrypoint, entryErrors);
    return map;
  }, /* @__PURE__ */ new Map());
  Array.from(entrypointErrors.entries()).forEach(([entrypoint, errors2]) => {
    import_consola3.default.log((0, import_node_path15.relative)(cwd, entrypoint.inputPath));
    console.log();
    errors2.forEach((err) => {
      const type = err.type === "error" ? import_picocolors5.default.red("ERROR") : import_picocolors5.default.yellow("WARN");
      const recieved = import_picocolors5.default.dim(`(recieved: ${JSON.stringify(err.value)})`);
      import_consola3.default.log(`  - ${type} ${err.message} ${recieved}`);
    });
    console.log();
  });
}

// src/core/build.ts
async function build(config) {
  await registerWxt("build", config);
  return await internalBuild();
}

// src/core/clean.ts
var import_node_path16 = __toESM(require("path"), 1);
var import_fast_glob4 = __toESM(require("fast-glob"), 1);
var import_fs_extra13 = __toESM(require("fs-extra"), 1);
var import_consola4 = require("consola");
var import_picocolors6 = __toESM(require("picocolors"), 1);
async function clean(root = process.cwd()) {
  import_consola4.consola.info("Cleaning Project");
  const tempDirs = [
    "node_modules/.vite",
    "node_modules/.cache",
    "**/.wxt",
    ".output/*"
  ];
  import_consola4.consola.debug("Looking for:", tempDirs.map(import_picocolors6.default.cyan).join(", "));
  const directories = await (0, import_fast_glob4.default)(tempDirs, {
    cwd: import_node_path16.default.resolve(root),
    absolute: true,
    onlyDirectories: true,
    deep: 2
  });
  if (directories.length === 0) {
    import_consola4.consola.debug("No generated files found.");
    return;
  }
  import_consola4.consola.debug(
    "Found:",
    directories.map((dir) => import_picocolors6.default.cyan(import_node_path16.default.relative(root, dir))).join(", ")
  );
  for (const directory of directories) {
    await import_fs_extra13.default.rm(directory, { force: true, recursive: true });
    import_consola4.consola.debug("Deleted " + import_picocolors6.default.cyan(import_node_path16.default.relative(root, directory)));
  }
}

// src/core/define-config.ts
function defineConfig(config) {
  return config;
}

// src/core/define-runner-config.ts
function defineRunnerConfig(config) {
  return config;
}

// src/core/runners/wsl.ts
var import_node_path17 = require("path");
function createWslRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot open browser when using WSL. Load "${(0, import_node_path17.relative)(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/web-ext.ts
var import_defu3 = __toESM(require("defu"), 1);
function createWebExtRunner() {
  let runner;
  return {
    async openBrowser() {
      const startTime = Date.now();
      if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
        throw Error(
          "Dev mode does not support Firefox MV3. For alternatives, see https://github.com/wxt-dev/wxt/issues/230#issuecomment-1806881653"
        );
      }
      const webExtLogger = await import("web-ext-run/util/logger");
      webExtLogger.consoleStream.write = ({ level, msg, name }) => {
        if (level >= ERROR_LOG_LEVEL)
          wxt.logger.error(name, msg);
        if (level >= WARN_LOG_LEVEL)
          wxt.logger.warn(msg);
      };
      const wxtUserConfig = wxt.config.runnerConfig.config;
      const userConfig = {
        console: wxtUserConfig?.openConsole,
        devtools: wxtUserConfig?.openDevtools,
        startUrl: wxtUserConfig?.startUrls,
        ...wxt.config.browser === "firefox" ? {
          firefox: wxtUserConfig?.binaries?.firefox,
          firefoxProfile: wxtUserConfig?.firefoxProfile,
          prefs: wxtUserConfig?.firefoxPrefs,
          args: wxtUserConfig?.firefoxArgs
        } : {
          chromiumBinary: wxtUserConfig?.binaries?.[wxt.config.browser],
          chromiumProfile: wxtUserConfig?.chromiumProfile,
          chromiumPref: (0, import_defu3.default)(
            wxtUserConfig?.chromiumPref,
            DEFAULT_CHROMIUM_PREFS
          ),
          args: wxtUserConfig?.chromiumArgs
        }
      };
      const finalConfig = {
        ...userConfig,
        target: wxt.config.browser === "firefox" ? "firefox-desktop" : "chromium",
        sourceDir: wxt.config.outDir,
        // WXT handles reloads, so disable auto-reload behaviors in web-ext
        noReload: true,
        noInput: true
      };
      const options = {
        // Don't call `process.exit(0)` after starting web-ext
        shouldExitProgram: false
      };
      wxt.logger.debug("web-ext config:", finalConfig);
      wxt.logger.debug("web-ext options:", options);
      const webExt = await import("web-ext-run");
      runner = await webExt.default.cmd.run(finalConfig, options);
      const duration = Date.now() - startTime;
      wxt.logger.success(`Opened browser in ${formatDuration(duration)}`);
    },
    async closeBrowser() {
      return await runner?.exit();
    }
  };
}
var WARN_LOG_LEVEL = 40;
var ERROR_LOG_LEVEL = 50;
var DEFAULT_CHROMIUM_PREFS = {
  devtools: {
    synced_preferences_sync_disabled: {
      // Remove content scripts from sourcemap debugger ignore list so stack traces
      // and log locations show up properly, see:
      // https://github.com/wxt-dev/wxt/issues/236#issuecomment-1915364520
      skipContentScripts: false
    }
  }
};

// src/core/runners/safari.ts
var import_node_path18 = require("path");
function createSafariRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot Safari using web-ext. Load "${(0, import_node_path18.relative)(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/manual.ts
var import_node_path19 = require("path");
function createManualRunner() {
  return {
    async openBrowser() {
      wxt.logger.info(
        `Load "${(0, import_node_path19.relative)(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/utils/wsl.ts
async function isWsl() {
  const { default: isWsl2 } = await import("is-wsl");
  return isWsl2;
}

// src/core/runners/index.ts
async function createExtensionRunner() {
  if (wxt.config.browser === "safari")
    return createSafariRunner();
  if (await isWsl())
    return createWslRunner();
  if (wxt.config.runnerConfig.config?.disabled)
    return createManualRunner();
  return createWebExtRunner();
}

// src/core/create-server.ts
var import_consola5 = require("consola");
var import_async_mutex = require("async-mutex");
var import_picocolors7 = __toESM(require("picocolors"), 1);
var import_node_path20 = require("path");
async function createServer(inlineConfig) {
  const port = await getPort();
  const hostname = "localhost";
  const origin = `http://${hostname}:${port}`;
  const serverInfo = {
    port,
    hostname,
    origin
  };
  const buildAndOpenBrowser = async () => {
    server.currentOutput = await internalBuild();
    try {
      server.watcher.add(getExternalOutputDependencies(server));
    } catch (err) {
      wxt.config.logger.warn("Failed to register additional file paths:", err);
    }
    await runner.openBrowser();
  };
  const closeAndRecreateRunner = async () => {
    await runner.closeBrowser();
    await wxt.reloadConfig();
    runner = await createExtensionRunner();
  };
  const server = {
    ...serverInfo,
    get watcher() {
      return builderServer.watcher;
    },
    get ws() {
      return builderServer.ws;
    },
    currentOutput: void 0,
    async start() {
      await builderServer.listen();
      wxt.logger.success(`Started dev server @ ${serverInfo.origin}`);
      await buildAndOpenBrowser();
    },
    async stop() {
      await runner.closeBrowser();
      await builderServer.close();
    },
    async restart() {
      await closeAndRecreateRunner();
      await buildAndOpenBrowser();
    },
    transformHtml(url2, html, originalUrl) {
      return builderServer.transformHtml(url2, html, originalUrl);
    },
    reloadContentScript(contentScript) {
      server.ws.send("wxt:reload-content-script", contentScript);
    },
    reloadPage(path11) {
      server.ws.send("wxt:reload-page", path11);
    },
    reloadExtension() {
      server.ws.send("wxt:reload-extension");
    },
    async restartBrowser() {
      await closeAndRecreateRunner();
      await runner.openBrowser();
    }
  };
  await registerWxt("serve", inlineConfig, server);
  let [runner, builderServer] = await Promise.all([
    createExtensionRunner(),
    wxt.config.builder.createServer(server)
  ]);
  server.ws.on("wxt:background-initialized", () => {
    if (server.currentOutput == null)
      return;
    reloadContentScripts(server.currentOutput.steps, server);
  });
  const reloadOnChange = createFileReloader(server);
  server.watcher.on("all", reloadOnChange);
  return server;
}
async function getPort() {
  const { default: getPort2, portNumbers } = await import("get-port");
  return await getPort2({ port: portNumbers(3e3, 3010) });
}
function createFileReloader(server) {
  const fileChangedMutex = new import_async_mutex.Mutex();
  const changeQueue = [];
  return async (event, path11) => {
    await wxt.reloadConfig();
    if (path11.startsWith(wxt.config.outBaseDir))
      return;
    changeQueue.push([event, path11]);
    await fileChangedMutex.runExclusive(async () => {
      if (server.currentOutput == null)
        return;
      const fileChanges = changeQueue.splice(0, changeQueue.length).map(([_, file]) => file);
      if (fileChanges.length === 0)
        return;
      const changes = detectDevChanges(fileChanges, server.currentOutput);
      if (changes.type === "no-change")
        return;
      if (changes.type === "full-restart") {
        wxt.logger.info("Config changed, restarting server...");
        server.restart();
        return;
      }
      if (changes.type === "browser-restart") {
        wxt.logger.info("Runner config changed, restarting browser...");
        server.restartBrowser();
        return;
      }
      wxt.logger.info(
        `Changed: ${Array.from(new Set(fileChanges)).map((file) => import_picocolors7.default.dim((0, import_node_path20.relative)(wxt.config.root, file))).join(", ")}`
      );
      const allEntrypoints = await findEntrypoints();
      const { output: newOutput } = await rebuild(
        allEntrypoints,
        // TODO: this excludes new entrypoints, so they're not built until the dev command is restarted
        changes.rebuildGroups,
        changes.cachedOutput
      );
      server.currentOutput = newOutput;
      switch (changes.type) {
        case "extension-reload":
          server.reloadExtension();
          import_consola5.consola.success(`Reloaded extension`);
          break;
        case "html-reload":
          const { reloadedNames } = reloadHtmlPages(
            changes.rebuildGroups,
            server
          );
          import_consola5.consola.success(`Reloaded: ${getFilenameList(reloadedNames)}`);
          break;
        case "content-script-reload":
          reloadContentScripts(changes.changedSteps, server);
          const rebuiltNames = changes.rebuildGroups.flat().map((entry) => entry.name);
          import_consola5.consola.success(`Reloaded: ${getFilenameList(rebuiltNames)}`);
          break;
      }
    });
  };
}
function reloadContentScripts(steps, server) {
  if (wxt.config.manifestVersion === 3) {
    steps.forEach((step) => {
      if (server.currentOutput == null)
        return;
      const entry = step.entrypoints;
      if (Array.isArray(entry) || entry.type !== "content-script")
        return;
      const js = [getEntrypointBundlePath(entry, wxt.config.outDir, ".js")];
      const cssMap = getContentScriptsCssMap(server.currentOutput, [entry]);
      const css = getContentScriptCssFiles([entry], cssMap);
      server.reloadContentScript(
        mapWxtOptionsToRegisteredContentScript(entry.options, js, css)
      );
    });
  } else {
    server.reloadExtension();
  }
}
function reloadHtmlPages(groups, server) {
  const htmlEntries = groups.flat().filter(isHtmlEntrypoint);
  htmlEntries.forEach((entry) => {
    const path11 = getEntrypointBundlePath(entry, wxt.config.outDir, ".html");
    server.reloadPage(path11);
  });
  return {
    reloadedNames: htmlEntries.map((entry) => entry.name)
  };
}
function getFilenameList(names) {
  return names.map((name) => {
    return import_picocolors7.default.cyan(name);
  }).join(import_picocolors7.default.dim(", "));
}
function getExternalOutputDependencies(server) {
  return server.currentOutput?.steps.flatMap((step, i) => {
    if (Array.isArray(step.entrypoints) && i === 0) {
      return [];
    }
    return step.chunks.flatMap((chunk) => {
      if (chunk.type === "asset")
        return [];
      return chunk.moduleIds;
    });
  }).filter(
    (file) => !file.includes("node_modules") && !file.startsWith("\0")
  ).map(unnormalizePath).filter((file) => !file.startsWith(wxt.config.root)) ?? [];
}

// src/core/initialize.ts
var import_prompts = __toESM(require("prompts"), 1);
var import_consola6 = require("consola");
var import_giget = require("giget");
var import_fs_extra14 = __toESM(require("fs-extra"), 1);
var import_node_path21 = __toESM(require("path"), 1);
var import_picocolors8 = __toESM(require("picocolors"), 1);
async function initialize(options) {
  import_consola6.consola.info("Initalizing new project");
  const templates = await listTemplates();
  const defaultTemplate = templates.find(
    (template) => template.name === options.template?.toLowerCase().trim()
  );
  const input = await (0, import_prompts.default)(
    [
      {
        name: "directory",
        type: () => options.directory == null ? "text" : void 0,
        message: "Project Directory",
        initial: options.directory
      },
      {
        name: "template",
        type: () => defaultTemplate == null ? "select" : void 0,
        message: "Choose a template",
        choices: templates.map((template) => ({
          title: TEMPLATE_COLORS[template.name]?.(template.name) ?? template.name,
          value: template
        }))
      },
      {
        name: "packageManager",
        type: () => options.packageManager == null ? "select" : void 0,
        message: "Package Manager",
        choices: [
          { title: import_picocolors8.default.red("npm"), value: "npm" },
          { title: import_picocolors8.default.yellow("pnpm"), value: "pnpm" },
          { title: import_picocolors8.default.cyan("yarn"), value: "yarn" },
          {
            title: `${import_picocolors8.default.magenta("bun")}${import_picocolors8.default.gray(" (experimental)")}`,
            value: "bun"
          }
        ]
      }
    ],
    {
      onCancel: () => process.exit(1)
    }
  );
  input.directory ??= options.directory;
  input.template ??= defaultTemplate;
  input.packageManager ??= options.packageManager;
  await cloneProject(input);
  const cdPath = import_node_path21.default.relative(process.cwd(), import_node_path21.default.resolve(input.directory));
  console.log();
  import_consola6.consola.log(
    `\u2728 WXT project created with the ${TEMPLATE_COLORS[input.template.name]?.(input.template.name) ?? input.template.name} template.`
  );
  console.log();
  import_consola6.consola.log("Next steps:");
  let step = 0;
  if (cdPath !== "")
    import_consola6.consola.log(`  ${++step}.`, import_picocolors8.default.cyan(`cd ${cdPath}`));
  import_consola6.consola.log(`  ${++step}.`, import_picocolors8.default.cyan(`${input.packageManager} install`));
  console.log();
}
async function listTemplates() {
  try {
    const res = await fetch("https://ungh.cc/repos/wxt-dev/wxt/files/main");
    if (res.status >= 300)
      throw Error(`Request failed with status ${res.status} ${res.statusText}`);
    const data = await res.json();
    return data.files.map((item) => item.path.match(/templates\/(.+)\/package\.json/)?.[1]).filter((name) => name != null).map((name) => ({ name, path: `templates/${name}` })).sort((l, r) => {
      const lWeight = TEMPLATE_SORT_WEIGHT[l.name] ?? Number.MAX_SAFE_INTEGER;
      const rWeight = TEMPLATE_SORT_WEIGHT[r.name] ?? Number.MAX_SAFE_INTEGER;
      const diff = lWeight - rWeight;
      if (diff !== 0)
        return diff;
      return l.name.localeCompare(r.name);
    });
  } catch (err) {
    throw Error(`Cannot load templates: ${JSON.stringify(err, null, 2)}`);
  }
}
async function cloneProject({
  directory,
  template,
  packageManager
}) {
  const { default: ora } = await import("ora");
  const spinner = ora("Downloading template").start();
  try {
    await (0, import_giget.downloadTemplate)(`gh:wxt-dev/wxt/${template.path}`, {
      dir: directory,
      force: true
    });
    await import_fs_extra14.default.move(
      import_node_path21.default.join(directory, "_gitignore"),
      import_node_path21.default.join(directory, ".gitignore")
    ).catch(
      (err) => import_consola6.consola.warn("Failed to move _gitignore to .gitignore:", err)
    );
    spinner.succeed();
  } catch (err) {
    spinner.fail();
    throw Error(`Failed to setup new project: ${JSON.stringify(err, null, 2)}`);
  }
}
var TEMPLATE_COLORS = {
  vanilla: import_picocolors8.default.blue,
  vue: import_picocolors8.default.green,
  react: import_picocolors8.default.cyan,
  svelte: import_picocolors8.default.red,
  solid: import_picocolors8.default.blue
};
var TEMPLATE_SORT_WEIGHT = {
  vanilla: 0,
  vue: 1,
  react: 2
};

// src/core/prepare.ts
async function prepare(config) {
  await registerWxt("build", config);
  wxt.logger.info("Generating types...");
  const entrypoints = await findEntrypoints();
  await generateTypesDir(entrypoints);
}

// src/core/zip.ts
var import_zip_dir = __toESM(require("zip-dir"), 1);
var import_node_path22 = require("path");
var import_fs_extra15 = __toESM(require("fs-extra"), 1);
var import_minimatch2 = require("minimatch");
async function zip(config) {
  await registerWxt("build", config);
  const output = await internalBuild();
  const start = Date.now();
  wxt.logger.info("Zipping extension...");
  const zipFiles = [];
  const projectName = wxt.config.zip.name ?? kebabCaseAlphanumeric(
    (await getPackageJson())?.name || (0, import_node_path22.dirname)(process.cwd())
  );
  const applyTemplate = (template) => template.replaceAll("{{name}}", projectName).replaceAll("{{browser}}", wxt.config.browser).replaceAll(
    "{{version}}",
    output.manifest.version_name ?? output.manifest.version
  ).replaceAll("{{manifestVersion}}", `mv${wxt.config.manifestVersion}`);
  await import_fs_extra15.default.ensureDir(wxt.config.outBaseDir);
  const outZipFilename = applyTemplate(wxt.config.zip.artifactTemplate);
  const outZipPath = (0, import_node_path22.resolve)(wxt.config.outBaseDir, outZipFilename);
  await (0, import_zip_dir.default)(wxt.config.outDir, {
    saveTo: outZipPath
  });
  zipFiles.push(outZipPath);
  if (wxt.config.browser === "firefox") {
    const sourcesZipFilename = applyTemplate(wxt.config.zip.sourcesTemplate);
    const sourcesZipPath = (0, import_node_path22.resolve)(wxt.config.outBaseDir, sourcesZipFilename);
    await (0, import_zip_dir.default)(wxt.config.zip.sourcesRoot, {
      saveTo: sourcesZipPath,
      filter(path11) {
        const relativePath = (0, import_node_path22.relative)(wxt.config.zip.sourcesRoot, path11);
        return wxt.config.zip.includeSources.some(
          (pattern) => (0, import_minimatch2.minimatch)(relativePath, pattern)
        ) || !wxt.config.zip.excludeSources.some(
          (pattern) => (0, import_minimatch2.minimatch)(relativePath, pattern)
        );
      }
    });
    zipFiles.push(sourcesZipPath);
  }
  await printFileList(
    wxt.logger.success,
    `Zipped extension in ${formatDuration(Date.now() - start)}`,
    wxt.config.outBaseDir,
    zipFiles
  );
  return zipFiles;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  build,
  clean,
  createServer,
  defineConfig,
  defineRunnerConfig,
  initialize,
  prepare,
  version,
  zip
});
